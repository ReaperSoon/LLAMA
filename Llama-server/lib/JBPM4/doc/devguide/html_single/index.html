<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">jBPM Developers Guide</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="en"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e1"/>jBPM Developers Guide</h1></div></div><hr/></div><div class="toc"><dl><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9">1.1. Target audience</a></span></dt><dt><span class="section"><a href="#d0e14">1.2. Overview</a></span></dt><dt><span class="section"><a href="#d0e33">1.3. Sources and WIKI</a></span></dt><dt><span class="section"><a href="#d0e51">1.4. Maven repository</a></span></dt><dt><span class="section"><a href="#d0e65">1.5. Library dependencies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#incubation">2. Incubation</a></span></dt><dd><dl><dt><span class="section"><a href="#timer">2.1. <code class="literal">timer</code> </a></span></dt><dd><dl><dt><span class="section"><a href="#duedateexpressions">2.1.1. Duedate expressions</a></span></dt><dt><span class="section"><a href="#businesscalendar">2.1.2. Business calendar</a></span></dt><dt><span class="section"><a href="#timertransition">2.1.3. Timer transition</a></span></dt><dt><span class="section"><a href="#timerevent">2.1.4. Timer event</a></span></dt><dt><span class="section"><a href="#timerbusinesstime">2.1.5. Timer business time</a></span></dt><dt><span class="section"><a href="#timerrepeat">2.1.6. Timer repeat</a></span></dt></dl></dd><dt><span class="section"><a href="#group">2.2. <code class="literal">group</code> activity</a></span></dt><dd><dl><dt><span class="section"><a href="#groupsimple">2.2.1. <code class="literal">group</code> simple</a></span></dt><dt><span class="section"><a href="#grouptimer">2.2.2. <code class="literal">group</code> timer</a></span></dt><dt><span class="section"><a href="#groupmultipleentries">2.2.3. <code class="literal">group</code> multiple entries</a></span></dt><dt><span class="section"><a href="#groupconcurrency">2.2.4. <code class="literal">group</code> concurrency</a></span></dt><dt><span class="section"><a href="#groupsecret">2.2.5. <code class="literal">group</code> secret</a></span></dt></dl></dd><dt><span class="section"><a href="#foreach">2.3. Multiplicative split with <code class="literal">foreach</code></a></span></dt><dt><span class="section"><a href="#java">2.4. <code class="literal">java</code> activity</a></span></dt><dt><span class="section"><a href="#assign">2.5. <code class="literal">assign</code></a></span></dt><dt><span class="section"><a href="#rulesdeployer">2.6. Rules deployer</a></span></dt><dt><span class="section"><a href="#rulesdecision">2.7. <code class="literal">rules-decision</code> activity</a></span></dt><dt><span class="section"><a href="#rules">2.8. <code class="literal">rules</code> activity</a></span></dt><dt><span class="section"><a href="#jms">2.9. <code class="literal">jms</code> activity</a></span></dt><dd><dl><dt><span class="section"><a href="#mockjmsproviderforeasytesting">2.9.1. Mock JMS provider for easy testing</a></span></dt><dt><span class="section"><a href="#testmessages">2.9.2. Text messages</a></span></dt><dt><span class="section"><a href="#objectmessages">2.9.3. Object messages</a></span></dt><dt><span class="section"><a href="#mapmessages">2.9.4. Map messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1420">2.10. History session chain</a></span></dt><dt><span class="section"><a href="#d0e1452">2.11. Creating identity groups</a></span></dt><dt><span class="section"><a href="#taskforms">2.12. Task forms</a></span></dt><dd><dl><dt><span class="section"><a href="#taskformsusage">2.12.1. Usage</a></span></dt><dt><span class="section"><a href="#taskformsformat">2.12.2. Form format</a></span></dt></dl></dd><dt><span class="section"><a href="#instancemigration">2.13. Instance Migration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1541">2.13.1. Simple Migration</a></span></dt><dt><span class="section"><a href="#d0e1558">2.13.2. Ending Running Instances</a></span></dt><dt><span class="section"><a href="#d0e1569">2.13.3. Version Ranges</a></span></dt><dt><span class="section"><a href="#d0e1589">2.13.4. Activity Mappings</a></span></dt><dt><span class="section"><a href="#d0e1600">2.13.5. Migration Handlers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1611">2.14. User object caching</a></span></dt><dt><span class="section"><a href="#d0e1621">2.15. Transactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1624">2.15.1. Standalone transactions</a></span></dt><dt><span class="section"><a href="#d0e1629">2.15.2. JTA transactions</a></span></dt><dt><span class="section"><a href="#d0e1634">2.15.3. User transactions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#bpmn2">3. BPMN 2.0</a></span></dt><dd><dl><dt><span class="section"><a href="#whatIsBpmn">3.1. What is BPMN 2.0?</a></span></dt><dt><span class="section"><a href="#historyAndGodl">3.2. History and goal</a></span></dt><dt><span class="section"><a href="#jpdlVsBpmn2">3.3. JPDL vs BPMN 2.0</a></span></dt><dt><span class="section"><a href="#Bpmn2Execution">3.4. Bpmn 2.0 execution</a></span></dt><dt><span class="section"><a href="#bpmn2Config">3.5. Configuration</a></span></dt><dt><span class="section"><a href="#bpmn2Examples">3.6. Examples</a></span></dt><dt><span class="section"><a href="#definitionsAndProcess">3.7. Process root element</a></span></dt><dt><span class="section"><a href="#basicConstructs">3.8. Basic constructs</a></span></dt><dd><dl><dt><span class="section"><a href="#basicConstructsEvents">3.8.1. Events</a></span></dt><dt><span class="section"><a href="#noneStartEvent">3.8.2. Event: None start event</a></span></dt><dt><span class="section"><a href="#noneEndEvent">3.8.3. Event: None end event</a></span></dt><dt><span class="section"><a href="#terminateEndEvent">3.8.4. Event: Terminate end event</a></span></dt><dt><span class="section"><a href="#sequenceFlow">3.8.5. Sequence Flow</a></span></dt><dt><span class="section"><a href="#gateway">3.8.6. Gateways</a></span></dt><dt><span class="section"><a href="#exclusiveGateway">3.8.7. Gateway: Exclusive Gateway</a></span></dt><dt><span class="section"><a href="#parallelGateway">3.8.8. Gateway: Parallel Gateway</a></span></dt><dt><span class="section"><a href="#inclusiveGateway">3.8.9. Gateway: Inclusive Gateway</a></span></dt><dt><span class="section"><a href="#task">3.8.10. Tasks</a></span></dt><dt><span class="section"><a href="#userTask">3.8.11. Task: User Task</a></span></dt><dt><span class="section"><a href="#serviceTask">3.8.12. Task: Java Service Task</a></span></dt><dt><span class="section"><a href="#scriptTask">3.8.13. Task: Script Task</a></span></dt><dt><span class="section"><a href="#manualTask">3.8.14. Task: Manual task</a></span></dt><dt><span class="section"><a href="#receiveTaskJava">3.8.15. Task: Java Receive task</a></span></dt></dl></dd><dt><span class="section"><a href="#advancedConstructs">3.9. Advanced constructs</a></span></dt><dd><dl><dt><span class="section"><a href="#embeddedSubProcess">3.9.1. Embedded sub-process</a></span></dt><dt><span class="section"><a href="#Timer start event">3.9.2. Timer start event</a></span></dt><dt><span class="section"><a href="#intermediateEvents">3.9.3. Intermediate events</a></span></dt><dt><span class="section"><a href="#intermediateCatchTimer">3.9.4. Intermediate catch event: Timer </a></span></dt></dl></dd><dt><span class="section"><a href="#completeExample">3.10. Complete example (including console task forms)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#migrationfromjbpm3">4. Migration from jBPM 3</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2785">4.1. Goals of jBPM 4</a></span></dt><dt><span class="section"><a href="#d0e2799">4.2. Known limitations</a></span></dt><dt><span class="section"><a href="#processconversiontool">4.3. Process conversion tool</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2840">4.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e2850">4.3.2. Arguments</a></span></dt><dt><span class="section"><a href="#d0e2862">4.3.3. Usage examples</a></span></dt><dt><span class="section"><a href="#d0e2867">4.3.4. Advanced</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2875">4.4. Translations and changes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#processvirtualmachine">5. The Process Virtual Machine</a></span></dt><dt><span class="chapter"><a href="#architecture">6. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#apis">6.1. APIs</a></span></dt><dt><span class="section"><a href="#d0e3040">6.2. Activity API</a></span></dt><dt><span class="section"><a href="#d0e3054">6.3. Event listener API</a></span></dt><dt><span class="section"><a href="#d0e3061">6.4. Client API</a></span></dt><dt><span class="section"><a href="#d0e3068">6.5. Environment</a></span></dt><dt><span class="section"><a href="#d0e3095">6.6. Commands</a></span></dt><dt><span class="section"><a href="#d0e3103">6.7. Services</a></span></dt></dl></dd><dt><span class="chapter"><a href="#implementingbasicactivities">7. Implementing basic activities</a></span></dt><dd><dl><dt><span class="section"><a href="#activity">7.1. ActivityBehaviour</a></span></dt><dt><span class="section"><a href="#activitybehaviourexample">7.2. ActivityBehaviour example</a></span></dt><dt><span class="section"><a href="#externalactivitybehaviour">7.3. ExternalActivityBehaviour</a></span></dt><dt><span class="section"><a href="#externalactivityexample">7.4. ExternalActivity example</a></span></dt><dt><span class="section"><a href="#basicprocessexecution">7.5. Basic process execution</a></span></dt><dt><span class="section"><a href="#events">7.6. Events</a></span></dt><dt><span class="section"><a href="#d0e3719">7.7. Event propagation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#processanatomy">8. Process anatomy</a></span></dt><dt><span class="chapter"><a href="#advancedgraphexecution">9. Advanced graph execution</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3958">9.1. Loops</a></span></dt><dt><span class="section"><a href="#implicitproceedbehaviour">9.2. Implicit proceed behaviour</a></span></dt><dt><span class="section"><a href="#functionalactivities">9.3. Functional activities</a></span></dt><dt><span class="section"><a href="#executionandthreads">9.4. Execution and threads</a></span></dt><dt><span class="section"><a href="#d0e4087">9.5. Process concurrency</a></span></dt><dt><span class="section"><a href="#d0e4127">9.6. Exception handlers</a></span></dt><dt><span class="section"><a href="#d0e4157">9.7. Process modifications</a></span></dt><dt><span class="section"><a href="#d0e4163">9.8. Locking and execution state</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">10. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4210">10.1. Configuration basics</a></span></dt><dt><span class="section"><a href="#customizingthebusinesscalendar">10.2. Customizing the business calendar</a></span></dt><dt><span class="section"><a href="#customizingtheidentitycomponent">10.3. Customizing the identity component</a></span></dt></dl></dd><dt><span class="chapter"><a href="#persistence">11. Persistence</a></span></dt><dt><span class="chapter"><a href="#jobexecutor">12. JobExecutor</a></span></dt><dd><dl><dt><span class="section"><a href="#overview">12.1. Overview</a></span></dt><dt><span class="section"><a href="#configuration">12.2. Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mailsupport">13. Advanced Mail Support</a></span></dt><dd><dl><dt><span class="section"><a href="#mailproducers">13.1. Producers</a></span></dt><dd><dl><dt><span class="section"><a href="#defaultmailproducer">13.1.1. Default Producer</a></span></dt></dl></dd><dt><span class="section"><a href="#mailtemplates">13.2. Templates</a></span></dt><dt><span class="section"><a href="#mailservers">13.3. Servers</a></span></dt><dd><dl><dt><span class="section"><a href="#multiplemailservers">13.3.1. Multiple Servers</a></span></dt></dl></dd><dt><span class="section"><a href="#custommailproducers">13.4. Custom Mail Producers</a></span></dt><dd><dl><dt><span class="section"><a href="#extenddefaultmailproducer">13.4.1. Extending the default mail producer</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#softwarelogging">14. Software logging</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4626">14.1. Configuration</a></span></dt><dt><span class="section"><a href="#d0e4645">14.2. Categories</a></span></dt><dt><span class="section"><a href="#d0e4658">14.3. JDK logging</a></span></dt><dt><span class="section"><a href="#d0e4688">14.4. Debugging persistence</a></span></dt></dl></dd><dt><span class="chapter"><a href="#history">15. History</a></span></dt><dt><span class="chapter"><a href="#jbossintegration">16. JBoss Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4736">16.1. Packaging process archives</a></span></dt><dt><span class="section"><a href="#d0e4743">16.2. Deploying processes archives to a JBoss instance</a></span></dt><dt><span class="section"><a href="#d0e4752">16.3. Process deployments and versioning</a></span></dt><dt><span class="section"><a href="#d0e4760">16.4. ProcessEngine and J2EE/JEE programming models</a></span></dt></dl></dd><dt><span class="chapter"><a href="#springIntegration">17. Spring Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#spring_overview">17.1. Overview</a></span></dt><dt><span class="section"><a href="#spring_configuration">17.2. Configuration</a></span></dt><dt><span class="section"><a href="#spring_usage">17.3. Usage</a></span></dt><dt><span class="section"><a href="#spring_testing">17.4. Testing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#signavio">18. Signavio web modeler</a></span></dt><dd><dl><dt><span class="section"><a href="#signavioIntroduction">18.1. Introduction</a></span></dt><dt><span class="section"><a href="#signavioInstallation">18.2. Installation</a></span></dt><dt><span class="section"><a href="#signavioConfiguration">18.3. Configuration</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="introduction"/>Chapter 1. Introduction</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e9">1.1. Target audience</a></span></dt><dt><span class="section"><a href="#d0e14">1.2. Overview</a></span></dt><dt><span class="section"><a href="#d0e33">1.3. Sources and WIKI</a></span></dt><dt><span class="section"><a href="#d0e51">1.4. Maven repository</a></span></dt><dt><span class="section"><a href="#d0e65">1.5. Library dependencies</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9"/>1.1. Target audience</h2></div></div></div><p>This developers guide is intended for experienced developers that 
    want to get the full flexibility out of jBPM.  The features described in this 
    developers guide are currently not supported.  Use at your own risk. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14"/>1.2. Overview</h2></div></div></div><p><a href="#incubation" title="Chapter 2. Incubation">Chapter 2, <i xmlns:xlink="http://www.w3.org/1999/xlink">Incubation</i></a> explains the features that are intended to 
    move to the userguide eventually and become part of the supported offering.  
    Do note that incubation features are not yet considered stable (ie. there 
    could be major syntax or implementation changes in next versions).  
    </p><p><a href="#bpmn2" title="Chapter 3. BPMN 2.0">Chapter 3, <i xmlns:xlink="http://www.w3.org/1999/xlink">BPMN 2.0</i></a> shows how the BPMN 2.0 process language can be used with jBPM.    
    </p><p><a href="#processvirtualmachine" title="Chapter 5. The Process Virtual Machine">Chapter 5, <i xmlns:xlink="http://www.w3.org/1999/xlink">The Process Virtual Machine</i></a> through <a href="#advancedgraphexecution" title="Chapter 9. Advanced graph execution">Chapter 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Advanced graph execution</i></a>
    explain the core of jBPM, the process virtual machine (PVM) and how activity 
    and event listener can be build for it.
    </p><p><a href="#configuration" title="Chapter 10. Configuration">Chapter 10, <i xmlns:xlink="http://www.w3.org/1999/xlink">Configuration</i></a> through <a href="#signavio" title="Chapter 18. Signavio web modeler">Chapter 18, <i xmlns:xlink="http://www.w3.org/1999/xlink">Signavio web modeler</i></a>
    explain advanced usage of the jBPM framework.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e33"/>1.3. Sources and WIKI</h2></div></div></div><p>The source code for jBPM can be found in our <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/">SVN</a> repository:</p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://anonsvn.jboss.org/repos/jbpm/jbpm4/">https://anonsvn.jboss.org/repos/jbpm/jbpm4/</a><p>A description of how to build the sources is available in the wiki:</p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jboss.org/community/docs/DOC-12867">http://www.jboss.org/community/docs/DOC-12867</a><p>The jBPM WIKI is located here:</p><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.jboss.org/community/docs/DOC-11184">http://www.jboss.org/community/docs/DOC-11184</a></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e51"/>1.4. Maven repository</h2></div></div></div><p>You can use jBPM with the libraries that ship in the distribution.  The <code class="literal">jbpm.jar</code>
    in the distribution contains the classes of many jBPM modules: jbpm-api, jbpm-log, jbpm-test-base, jbpm-pvm,
    jbpm-jpdl and jbpm-enterprise.  So the single <code class="literal">jbpm.jar</code> in the distribution 
    does not allow to make a compile time distinction between the API classes and the implementation classes.
    If you prefer to build your project with only a dependency on jBPM's API, then 
    our repository can be used directly.  It is located here:
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://repository.jboss.com/maven2/org/jbpm/jbpm4/">http://repository.jboss.com/maven2/org/jbpm/jbpm4/</a>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e65"/>1.5. Library dependencies</h2></div></div></div><p>If you want to install/deploy jBPM into your own application, this is still as easy
    as it was before: just put the right libs in your application classpath.  We didn't yet clean 
    up the dependency description in the maven pom files.  So we can't yet give the exact 
    minimal set of libraries from the <code class="literal">lib</code> directory that you need to include
    in your application (See Jira issue 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jira.jboss.org/jira/browse/JBPM-2556">JBPM-2556</a>
    and vote for it if you want to let us know that this issue has priority for you).
    The versions of the libraries that are in the <code class="literal">lib</code>
    directory are the ones that we tested with.  So we recommend you to use those very versions
    of the libs.  To help you on your way, here's the current maven dependency list for jPDL:
    </p><pre class="programlisting">[INFO] ------------------------------------------------------------------------
[INFO] Building jBPM 4 - jPDL
[INFO]    task-segment: [dependency:tree]
[INFO] ------------------------------------------------------------------------
[INFO] [dependency:tree]
[INFO] org.jbpm.jbpm4:jbpm-jpdl:jar:4.0
[INFO] +- org.jbpm.jbpm4:jbpm-pvm:jar:4.0:compile
[INFO] |  +- org.jbpm.jbpm4:jbpm-api:jar:4.0:compile
[INFO] |  |  \- jboss:jboss-j2ee:jar:4.2.2.GA:compile
[INFO] |  +- org.jbpm.jbpm4:jbpm-log:jar:4.0:compile
[INFO] |  +- org.jbpm.jbpm4:jbpm-test-base:jar:4.0:compile
[INFO] |  |  \- org.hibernate:hibernate-core:jar:3.3.1.GA:compile
[INFO] |  |     +- antlr:antlr:jar:2.7.6:compile
[INFO] |  |     \- commons-collections:commons-collections:jar:3.1:compile
[INFO] |  +- org.apache.ant:ant:jar:1.7.0:compile
[INFO] |  |  \- org.apache.ant:ant-launcher:jar:1.7.0:compile
[INFO] |  +- log4j:log4j:jar:1.2.14:compile
[INFO] |  +- juel:juel:jar:2.1.0:compile
[INFO] |  +- juel:juel-impl:jar:2.1.0:compile
[INFO] |  +- juel:juel-engine:jar:2.1.0:compile
[INFO] |  +- org.slf4j:slf4j-api:jar:1.5.2:compile
[INFO] |  +- org.slf4j:slf4j-jdk14:jar:1.5.2:compile
[INFO] |  +- org.jboss.identity.idm:idm-core:jar:1.0.0.Beta1:compile
[INFO] |  |  +- org.jboss.identity.idm:idm-common:jar:1.0.0.Beta1:compile
[INFO] |  |  +- org.jboss.identity.idm:idm-api:jar:1.0.0.Beta1:compile
[INFO] |  |  +- org.jboss.identity.idm:idm-spi:jar:1.0.0.Beta1:compile
[INFO] |  |  \- com.sun.xml.bind:jaxb-impl:jar:2.1.8:compile
[INFO] |  |     \- javax.xml.bind:jaxb-api:jar:2.1:compile
[INFO] |  |        \- javax.xml.stream:stax-api:jar:1.0-2:compile
[INFO] |  +- org.jboss.identity.idm:idm-hibernate:jar:1.0.0.Beta1:compile
[INFO] |  |  +- javassist:javassist:jar:3.4.GA:compile
[INFO] |  |  +- org.hibernate:hibernate-cglib-repack:jar:2.1_3:compile
[INFO] |  |  \- org.slf4j:slf4j-log4j12:jar:1.5.2:compile
[INFO] |  +- org.hibernate:hibernate-entitymanager:jar:3.4.0.GA:compile
[INFO] |  |  +- org.hibernate:ejb3-persistence:jar:1.0.2.GA:compile
[INFO] |  |  +- org.hibernate:hibernate-commons-annotations:jar:3.1.0.GA:compile
[INFO] |  |  +- org.hibernate:hibernate-annotations:jar:3.4.0.GA:compile
[INFO] |  |  +- dom4j:dom4j:jar:1.6.1:compile
[INFO] |  |  |  \- xml-apis:xml-apis:jar:1.0.b2:compile
[INFO] |  |  \- javax.transaction:jta:jar:1.1:compile
[INFO] |  +- org.livetribe:livetribe-jsr223:jar:2.0.5:compile
[INFO] |  \- javax.mail:mail:jar:1.4.1:compile
[INFO] |     \- javax.activation:activation:jar:1.1:compile
[INFO] +- junit:junit:jar:3.8.1:compile
[INFO] \- hsqldb:hsqldb:jar:1.8.0.7:test
[INFO] ------------------------------------------------------------------------</pre><p>The jboss idm dependencies in sections 
    <code class="literal">org.jboss.identity.idm:*</code> can be ignored, including the 
    <code class="literal">org.hibernate:hibernate-entitymanager</code> </p><p>This list should already get you started to select a small subset of libs instead of 
    including all the libs from the <code class="literal">${jbpm.home}/lib</code> directory.  
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="incubation"/>Chapter 2. Incubation</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#timer">2.1. <code class="literal">timer</code> </a></span></dt><dd><dl><dt><span class="section"><a href="#duedateexpressions">2.1.1. Duedate expressions</a></span></dt><dt><span class="section"><a href="#businesscalendar">2.1.2. Business calendar</a></span></dt><dt><span class="section"><a href="#timertransition">2.1.3. Timer transition</a></span></dt><dt><span class="section"><a href="#timerevent">2.1.4. Timer event</a></span></dt><dt><span class="section"><a href="#timerbusinesstime">2.1.5. Timer business time</a></span></dt><dt><span class="section"><a href="#timerrepeat">2.1.6. Timer repeat</a></span></dt></dl></dd><dt><span class="section"><a href="#group">2.2. <code class="literal">group</code> activity</a></span></dt><dd><dl><dt><span class="section"><a href="#groupsimple">2.2.1. <code class="literal">group</code> simple</a></span></dt><dt><span class="section"><a href="#grouptimer">2.2.2. <code class="literal">group</code> timer</a></span></dt><dt><span class="section"><a href="#groupmultipleentries">2.2.3. <code class="literal">group</code> multiple entries</a></span></dt><dt><span class="section"><a href="#groupconcurrency">2.2.4. <code class="literal">group</code> concurrency</a></span></dt><dt><span class="section"><a href="#groupsecret">2.2.5. <code class="literal">group</code> secret</a></span></dt></dl></dd><dt><span class="section"><a href="#foreach">2.3. Multiplicative split with <code class="literal">foreach</code></a></span></dt><dt><span class="section"><a href="#java">2.4. <code class="literal">java</code> activity</a></span></dt><dt><span class="section"><a href="#assign">2.5. <code class="literal">assign</code></a></span></dt><dt><span class="section"><a href="#rulesdeployer">2.6. Rules deployer</a></span></dt><dt><span class="section"><a href="#rulesdecision">2.7. <code class="literal">rules-decision</code> activity</a></span></dt><dt><span class="section"><a href="#rules">2.8. <code class="literal">rules</code> activity</a></span></dt><dt><span class="section"><a href="#jms">2.9. <code class="literal">jms</code> activity</a></span></dt><dd><dl><dt><span class="section"><a href="#mockjmsproviderforeasytesting">2.9.1. Mock JMS provider for easy testing</a></span></dt><dt><span class="section"><a href="#testmessages">2.9.2. Text messages</a></span></dt><dt><span class="section"><a href="#objectmessages">2.9.3. Object messages</a></span></dt><dt><span class="section"><a href="#mapmessages">2.9.4. Map messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1420">2.10. History session chain</a></span></dt><dt><span class="section"><a href="#d0e1452">2.11. Creating identity groups</a></span></dt><dt><span class="section"><a href="#taskforms">2.12. Task forms</a></span></dt><dd><dl><dt><span class="section"><a href="#taskformsusage">2.12.1. Usage</a></span></dt><dt><span class="section"><a href="#taskformsformat">2.12.2. Form format</a></span></dt></dl></dd><dt><span class="section"><a href="#instancemigration">2.13. Instance Migration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1541">2.13.1. Simple Migration</a></span></dt><dt><span class="section"><a href="#d0e1558">2.13.2. Ending Running Instances</a></span></dt><dt><span class="section"><a href="#d0e1569">2.13.3. Version Ranges</a></span></dt><dt><span class="section"><a href="#d0e1589">2.13.4. Activity Mappings</a></span></dt><dt><span class="section"><a href="#d0e1600">2.13.5. Migration Handlers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1611">2.14. User object caching</a></span></dt><dt><span class="section"><a href="#d0e1621">2.15. Transactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1624">2.15.1. Standalone transactions</a></span></dt><dt><span class="section"><a href="#d0e1629">2.15.2. JTA transactions</a></span></dt><dt><span class="section"><a href="#d0e1634">2.15.3. User transactions</a></span></dt></dl></dd></dl></div><p>This section documents some of the more advanced activities and 
  features of jPDL that are still in incubation.  These features 
  and activities are not supported yet,  but they are available for you
  to try and use.  There are no stability guarantees on these 
  activities and features; use them at your own risk.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="timer"/>2.1. <code class="literal">timer</code> </h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Timers will be changed before they are moved to the user guide. See <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://jira.jboss.org/browse/JBPM-2329">JBPM-2329</a>.</p></div><p>A timer can be specified in the <code class="literal">transition</code>
    element in wait state activities such as <code class="literal">state</code>s, 
    <code class="literal">task</code>s, <code class="literal">sub-process</code>es and 
    <code class="literal">group</code>s.  
    When such a timer fires, that transition is taken.
    </p><p>A timer can also be specified in custom events in wait state 
    activities such as <code class="literal">state</code>s, 
    <code class="literal">task</code>s, <code class="literal">sub-process</code>es and 
    <code class="literal">group</code>s.  The <code class="literal">timer</code> element 
    should then be the first element in the <code class="literal">on</code> element representing 
    the event. In that case the event fires upon the duedate of the timer.   
    </p><p>Timers are created when the activity is entered.  The timer can fire 
    when the execution remains in the activity until the <code class="literal">duedate</code>.
    When the execution leaves the activity, the timer is cancelled. 
    </p><div class="table"><a id="d0e153"/><p class="title"><b>Table 2.1. <code class="literal">timer</code> attributes:</b></p><div class="table-contents"><table summary="timer attributes:" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Required?</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">duedate</code></td><td><a href="#duedateexpressions" title="2.1.1. Duedate expressions">duedate expression</a></td><td> </td><td><span class="bold"><strong>required</strong></span></td><td>Specifies when the timer needs to fire.  For 
            example: <code class="literal">20 minutes</code> or
            <code class="literal">3 business days</code> or
            <code class="literal">#{proc_var} + 1 week</code> 
            </td></tr><tr><td><code class="literal">repeat</code></td><td><a href="#duedateexpressions" title="2.1.1. Duedate expressions">duedate expression</a></td><td> </td><td>optional</td><td>When a timer fires, this attribute specifies when the timer 
            needs to fire again.   For example: <code class="literal">20 minutes</code> or
            <code class="literal">3 business days</code> 
            </td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="duedateexpressions"/>2.1.1. Duedate expressions</h3></div></div></div><p>A duedate expression has the following syntax:</p><pre class="programlisting">[&lt;Base Date&gt; {+|-}] quantity [business] {second | seconds | minute | minutes | 
                     hour | hours | day | days | week | 
                     weeks | month | months | year | years}</pre><p>Where <code class="literal"><a href="#baseDate" title="2.1.1.1. Base date">Base Date</a></code> is specified as EL and 
      where <code class="literal">quantity</code> is a positive integer.
      </p><p>And adding the optional indication <code class="literal">business</code> means 
      that only business hours should be taken into account for this duration. Without 
      the indication business, the duration will be interpreted as an absolute time period.
      How to configure business hours is explained in <a href="#businesscalendar" title="2.1.2. Business calendar">Section 2.1.2, “Business calendar”</a>
      <span class="emphasis"><em>Note: 'business' is not supported when subtracting from a base date!</em></span>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="baseDate"/>2.1.1.1. Base date</h4></div></div></div><p>The base date can be specified in any JAVA Expression
      	Language expression that resolves to a JAVA Date or Calendar object.
      	Referencing variables of other object types, even a String in a date
      	format like '2036-02-12', will throw a JbpmException</p><p>NOTE: This baseDate is supported on the duedate and repeat attributes of all places where timers can be used, 
      	but also on the reminder of a task</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="duedateExamples"/>2.1.1.2. Examples</h4></div></div></div><p>The following examples of the usage are all possible</p><pre class="programlisting">&lt;timer name="daysBeforeHoliday" duedate="5 business days"&gt;...&lt;/timer&gt;

&lt;timer name="pensionDate" duedate="#{dateOfBirth} + 65 years" &gt;...&lt;/timer&gt;

&lt;timer name="pensionReminder" duedate="#{dateOfPension} - 1 year" &gt;...&lt;/timer&gt;

&lt;timer name="fireWorks" duedate="#{chineseNewYear} repeat="1 year" &gt;...&lt;/timer&gt;

&lt;reminder name="hitBoss" duedate="#{payRaiseDay} + 3 days" repeat="1 week" /&gt;

&lt;reminder name="hitBoss" duedate="#{payRaiseDay} + 3 days" repeat="#{iritationFactor}" /&gt;
        </pre><p>Remember, the following example, a subtraction in combination with 'business', is <span class="emphasis"><em>not</em></span> supported and will throw an exception, as will resulting due dates that will be in the past</p><pre class="programlisting">&lt;reminder name="toGoOrNotToGo" duedate="#{goLive} - 3 business days"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="businesscalendar"/>2.1.2. Business calendar</h3></div></div></div><p>The default configuration will contain a reference to the file
        <code class="literal">jbpm.business.calendar.xml</code>.  That contains a 
        configuration of business hours in the following format: 
      </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jbpm-configuration xmlns="http://jbpm.org/xsd/cfg"&gt;

  &lt;process-engine-context&gt;
      
      &lt;business-calendar&gt;
        &lt;monday    hours="9:00-12:00 and 12:30-17:00"/&gt;
        &lt;tuesday   hours="9:00-12:00 and 12:30-17:00"/&gt;
        &lt;wednesday hours="9:00-12:00 and 12:30-17:00"/&gt;
        &lt;thursday  hours="9:00-12:00 and 12:30-17:00"/&gt;
        &lt;friday    hours="9:00-12:00 and 12:30-17:00"/&gt;
        &lt;holiday period="01/07/2008 - 31/08/2008"/&gt;
      &lt;/business-calendar&gt;

  &lt;/process-engine-context&gt;

&lt;/jbpm-configuration&gt;</pre><p>
     If the default business calendar implementation is sufficient for you,
     you can simply adjust the timings in the xml configuration as shown above.
     </p><p>
     If the default implementation doesn't cover your use cases, you can easily
     write your own implementation by implementing the 
     <code class="literal">org.jbpm.pvm.internal.cal.BusinessCalendar</code> interface.
     </p><p>
     For example:
    </p><pre class="programlisting">
public class CustomBusinessCalendar implements BusinessCalendar {
  
  public Date add(Date date, String duration) {
    if ("my next birthday".equals(duration)) {
      GregorianCalendar gregorianCalendar = new GregorianCalendar();
      gregorianCalendar.set(Calendar.MONTH, Calendar.JULY);
      gregorianCalendar.set(Calendar.DAY_OF_MONTH, 21);
      return gregorianCalendar.getTime();
    }
    return null;
  }
}
     </pre><p>
     To configure the jBPM engine to use this custom business calendar, just add
     the following line to your <code class="literal">jbpm.cfg.xml</code>:
     </p><pre class="programlisting">
&lt;process-engine-context&gt;
    &lt;object class="org.jbpm.test.custombusinesscalendarimpl.CustomBusinessCalendar" /&gt;
&lt;/process-engine-context&gt;     
     </pre><p>
     </p><p>
     Take a look at the 
     <code class="literal">org.jbpm.test.custombusinesscalendarimpl.CustomBusinessCalendarImplTest</code> 
     for more information.
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="timertransition"/>2.1.3. Timer transition</h3></div></div></div><p>The example <code class="literal">org.jbpm.examples.timer.transition.TimerTransitionTest</code>
      shows how to put a timer on a transition.</p><div class="figure"><a id="process.timer.transition"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.timer.transition.png" align="middle" alt="The timer transition example process"/></div></div><p class="title"><b>Figure 2.1. The timer transition example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="TimerTransition" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="guardedWait" /&gt;
  &lt;/start&gt;

  &lt;state name="guardedWait"&gt;
    &lt;transition name="go on" to="next step" /&gt;
    &lt;transition name="timeout" to="escalation"&gt;
      <span class="bold"><strong>&lt;timer duedate="10 minutes" /&gt;</strong></span>
    &lt;/transition&gt;
  &lt;/state&gt;
  
  &lt;state name="next step" /&gt;
  &lt;state name="escalation" /&gt;

&lt;/process&gt;</pre><p>When an process instance for this process is started, it arrives immediately 
      in the <code class="literal">guardedWait</code> state.  At that time, a timer is created that will fire 
      after 10 minutes.  
      </p><pre class="programlisting">Execution processInstance = executionService
      .startProcessInstanceByKey("TimerTransition");</pre><p>With the following query, we can query for the timers related to the newly created 
      processInstance.  We know that there should be exactly one such timer.
      </p><pre class="programlisting">Job job = managementService.createJobQuery()
      .timers()
      .processInstanceId(processInstance.getId())
      .uniqueResult();
      </pre><p>In a unit test, we won't use the JobExecutor to execute the timer.  Instead,
      we execute timers directly in the thread of the unit test.  That way it is easy to 
      simulate one scenario though an execution.
      </p><p>So as the next step, we assume that the timer will fire.  We simulate this 
      by executing the timer programmatically:
      </p><pre class="programlisting">managementService.executeJob(job.getDbid());</pre><p>After that the process instance will have taken the 
      <code class="literal">timeout</code> transition and moved to the escalation state.  
      </p><pre class="programlisting">processInstance = executionService.findExecutionById(processInstance.getId());
assertEquals("escalation", processInstance.getActivityName());</pre><p>The second scenario in TimerTransitionTest shows that the 
      timer is cancelled in case the signal <code class="literal">go on</code> is given 
      before the timer fires.  In that case the execution ends up in the 
      <code class="literal">next step</code>.  
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="timerevent"/>2.1.4. Timer event</h3></div></div></div><p>Example TimerEventTest shows how to put a timer on a custom event.</p><div class="figure"><a id="process.timer.event"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.timer.event.png" align="middle" alt="The timer event example process"/></div></div><p class="title"><b>Figure 2.2. The timer event example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="TimerEvent" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="guardedWait" /&gt;
  &lt;/start&gt;

  &lt;state name="guardedWait" &gt;
    <span class="bold"><strong>&lt;on event="timeout"&gt;
      &lt;timer duedate="10 minutes"/&gt;
      &lt;event-listener class="org.jbpm.examples.timer.event.Escalate" /&gt;
    &lt;/on&gt;</strong></span>
    &lt;transition name="go on" to="next step" /&gt;
  &lt;/state&gt;
  
  &lt;state name="next step" /&gt;

&lt;/process&gt;</pre><p>In this case, if the execution is not signalled within 10 minutes after the 
      activity is started, the event <code class="literal">timeout</code> is fired 
      and the event listener <code class="literal">org.jbpm.examples.timer.event.Escalate</code>
      will be notified.
      </p><p>Again, if the <code class="literal">guardedWait</code> activity is ended within 
      10 minutes, then the timer is cancelled and the <code class="literal">Escalate</code> 
      event listener will not be notified.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="timerbusinesstime"/>2.1.5. Timer business time</h3></div></div></div><p>Example TimerBusinessTimeTest shows how business time works.</p><div class="figure"><a id="process.timer.event"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.timer.transition.png" align="middle" alt="The timer businesstime example process"/></div></div><p class="title"><b>Figure 2.3. The timer businesstime example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="TimerBusinessTime" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="guardedWait" /&gt;
  &lt;/start&gt;

  &lt;state name="guardedWait" &gt;
    &lt;transition name="go on" to="next step" /&gt;
    &lt;transition name="timeout" to="escalation" &gt;
      &lt;timer <span class="bold"><strong>duedate="9 business hours"</strong></span> /&gt; 
    &lt;/transition&gt;
  &lt;/state&gt;
  
  &lt;state name="next step" /&gt;
  &lt;state name="escalation" /&gt;

&lt;/process&gt;</pre><p>Suppose that a new <code class="literal">TimerBusinessTime</code> process instance is started
      at 11:30am on a tuesday.  The default configured business calendar specifies working hours 
      between 9:00-12:00 and 12:30-17:00.  So 9 business hours later results in an actual duedate 
      for the timer of wednesday 13:00 (1pm).
      </p><p>Since we do not know when the TimerBusinessTimeTest will be ran, we only assert 
      in the test that the actual duedate of the scheduled timer at least 24 hours ahead.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="timerrepeat"/>2.1.6. Timer repeat</h3></div></div></div><p>Example TimerRepeatTest shows how to put a timer with a repeat. The attribute 
      <code class="literal">repeat</code> on a timer will cause the timer to be rescheduled automatically
      after it is executed.
      </p><div class="figure"><a id="process.timer.repeat"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.timer.event.png" align="middle" alt="The timer repeat example process"/></div></div><p class="title"><b>Figure 2.4. The timer repeat example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="TimerRepeat" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="guardedWait" /&gt;
  &lt;/start&gt;

  &lt;state name="guardedWait"&gt;
    &lt;on event="timeout"&gt;
      &lt;timer duedate="20 minutes" <span class="bold"><strong>repeat="10 seconds"</strong></span> /&gt;
      &lt;event-listener class="org.jbpm.examples.timer.repeat.Escalate" /&gt;
    &lt;/on&gt;
    &lt;transition name="go on" to="next step"/&gt;
  &lt;/state&gt;
  
  &lt;state name="next step"/&gt;

&lt;/process&gt;</pre><p>When a new process is started, a timer is created and the duedate 
      will be 20 minutes ahead.  When the timer fires, a new timer will be created 
      with a duedate of 10 seconds ahead.  When that timer fires, a new timer will
      be created again 10 seconds ahead. And so on.
      </p><p>New timers will be created each time the timer fires until the 
      <code class="literal">guardedWait</code> state activity is ended with a signal.
      When the <code class="literal">guardedWait</code> state activity is ended, the 
      existing timer will be cancelled.  
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="group"/>2.2. <code class="literal">group</code> activity</h2></div></div></div><p>Groups a set of activities in a process together. Contained groups must be nested
      hierarchically. A group corresponds to a BPMN expanded sub process.</p><div class="table"><a id="d0e435"/><p class="title"><b>Table 2.2. <code class="literal">group</code> elements:</b></p><div class="table-contents"><table summary="group elements:" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Element</th><th>Multiplicity</th><th>Description</th></tr></thead><tbody><tr><td>any activity</td><td>0..*</td><td>Contained activities.
            </td></tr><tr><td><code class="literal">transition</code></td><td>0..*</td><td>Outgoing transitions for the group activity.
            </td></tr></tbody></table></div></div><br class="table-break"/><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="groupsimple"/>2.2.1. <code class="literal">group</code> simple</h3></div></div></div><p>This example scenario shows the basic operations of a <code class="literal">group</code>.
      </p><div class="figure"><a id="process.group.simple"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.group.simple.png" align="middle" alt="The simple group example process"/></div></div><p class="title"><b>Figure 2.5. The simple group example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="GroupSimple" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="evaluate document" /&gt;
  &lt;/start&gt;
  
  <span class="bold"><strong>&lt;group name="evaluate document"&gt;</strong></span>
    &lt;start&gt;
      &lt;transition to="distribute document" /&gt;
    &lt;/start&gt;
    &lt;state name="distribute document"&gt;
      &lt;transition to="collect feedback" /&gt;
    &lt;/state&gt;
    &lt;state name="collect feedback"&gt;
      &lt;transition name="approved" to="done" /&gt;
      &lt;transition name="rejected" to="update document" /&gt;
    &lt;/state&gt;
    &lt;state name="update document"&gt;
      &lt;transition to="distribute document" /&gt;
    &lt;/state&gt;
    &lt;end name="done" /&gt;
    &lt;transition to="publish document" /&gt;
  <span class="bold"><strong>&lt;/group&gt;</strong></span>
  
  &lt;state name="publish document" /&gt;

&lt;/process&gt;</pre><p>The next code snippet shows a test scenario that rejects a document
      when it comes in the <code class="literal">collect feedback</code> first time round.
      Then it goes through <code class="literal">update document</code>, <code class="literal">distribute document</code>
      and back to <code class="literal">collect feedback</code>.  The second time,  
      it will be approved.  All activities involved are wait <code class="literal">state</code>s.
      </p><pre class="programlisting">ProcessInstance processInstance = executionService
       .startProcessInstanceByKey("GroupSimple");
String pid = processInstance.getId();
assertEquals("distribute document", processInstance.getActivityName());

processInstance = executionService.signalExecutionById(pid);
assertEquals("collect feedback", processInstance.getActivityName());

processInstance = executionService.signalExecutionById(pid, "rejected");
assertEquals("update document", processInstance.getActivityName());

processInstance = executionService.signalExecutionById(pid);
assertEquals("distribute document", processInstance.getActivityName());

processInstance = executionService.signalExecutionById(pid);
assertEquals("collect feedback", processInstance.getActivityName());

processInstance = executionService.signalExecutionById(pid, "approved");
assertEquals("publish document", processInstance.getActivityName());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="grouptimer"/>2.2.2. <code class="literal">group</code> timer</h3></div></div></div><div class="figure"><a id="process.group.timer"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.group.timer.png" align="middle" alt="The group timer example process"/></div></div><p class="title"><b>Figure 2.6. The group timer example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="GroupTimer" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="evaluate document" /&gt;
  &lt;/start&gt;
  
  <span class="bold"><strong>&lt;group name="evaluate document"&gt;</strong></span>
    &lt;start&gt;
      &lt;transition to="approve" /&gt;
    &lt;/start&gt;
    &lt;state name="approve"&gt;
      &lt;transition to="done" /&gt;
    &lt;/state&gt;
    &lt;end name="done" /&gt;
    
    &lt;transition to="publish document" /&gt;
    <span class="bold"><strong>&lt;transition name="timeout" to="escalate"&gt;
      &lt;timer duedate="2 business hours" /&gt;
    &lt;/transition&gt;</strong></span>
    
  <span class="bold"><strong>&lt;/group&gt;</strong></span>
  
  &lt;state name="escalate" /&gt;
  &lt;state name="publish document" /&gt;

&lt;/process&gt;</pre><p>The next code snippet shows a test scenario in which the timer will 
      fire before the group activity <code class="literal">evaluate document</code> completes.
      </p><pre class="programlisting">ProcessInstance processInstance = executionService
       .startProcessInstanceByKey("GroupTimer");
Execution approveExecution = processInstance
       .findActiveExecutionIn("approve");
assertNotNull(approveExecution);

List&lt;Job&gt; jobs = managementService
  .createJobQuery()
  .processInstanceId(processInstance.getId())
  .list();

assertEquals(1, jobs.size());

Timer timer = (Timer) jobs.get(0);

managementService.executeJob(timer.getDbid());

processInstance = executionService
       .findProcessInstanceById(processInstance.getId());
assertNotNull(processInstance.findActiveExecutionIn("escalate") );</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="groupmultipleentries"/>2.2.3. <code class="literal">group</code> multiple entries</h3></div></div></div><p>This shows how a group can have multiple exclusive entry points.</p><p>Analogue to multiple entry points, a group can also have 
      multiple exit points.</p><div class="figure"><a id="process.group.multipleentries"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.group.multipleentries.png" align="middle" alt="The group multiple entries example process"/></div></div><p class="title"><b>Figure 2.7. The group multiple entries example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="GroupMultipleEntries" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="choose strategy" /&gt;
  &lt;/start&gt;
  
  &lt;decision name="choose strategy" expr="#{time}"&gt;
    <span class="bold"><strong>&lt;transition name="plenty" to="play" /&gt;
    &lt;transition name="running out" to="plan" /&gt;</strong></span>
  &lt;/decision&gt;
  
  &lt;group name="evaluate project"&gt;
    <span class="bold"><strong>&lt;start name="play"&gt;
      &lt;transition to="distribute document" /&gt;
    &lt;/start&gt;</strong></span>
    &lt;state name="distribute document" /&gt;

    <span class="bold"><strong>&lt;start name="plan"&gt;
      &lt;transition to="make planning" /&gt;
    &lt;/start&gt;</strong></span>
    &lt;state name="make planning" /&gt;
  &lt;/group&gt;
  
&lt;/process&gt;</pre><p>The following scenario will be when there is plenty of time: 
      </p><pre class="programlisting">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put("time", "plenty");

ProcessInstance pi = executionService
    .startProcessInstanceByKey("GroupMultipleEntries", variables);

assertNotNull(pi.findActiveExecutionIn("distribute document"));</pre><p>The following scenario will be when there is time is running out: 
      </p><pre class="programlisting">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put("time", "running out");

ProcessInstance pi = executionService
    .startProcessInstanceByKey("GroupMultipleEntries", variables);

assertNotNull(pi.findActiveExecutionIn("make planning"));</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="groupconcurrency"/>2.2.4. <code class="literal">group</code> concurrency</h3></div></div></div><p>This scenario shows how a group can be used to create concurrent paths 
      of execution.  When an execution arrives in a group, each activity that doesn't 
      have incoming transitions is started.  So the first activities don't have to be 
      start activities.  The group takes the default transition out when all contained 
      work is done.
      </p><div class="figure"><a id="process.group.concurrency"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.group.concurrency.png" align="middle" alt="The group concurrency example process"/></div></div><p class="title"><b>Figure 2.8. The group concurrency example process</b></p></div><br class="figure-break"/><pre class="programlisting">

&lt;process name="GroupConcurrency" xmlns="http://jbpm.org/4.4/jpdl"&gt;

  &lt;start&gt;
    &lt;transition to="evaluate project" /&gt;
  &lt;/start&gt;
  
  &lt;group name="evaluate project"&gt;
    <span class="bold"><strong>&lt;start&gt;
      &lt;transition to="distribute document" /&gt;
    &lt;/start&gt;</strong></span>
    &lt;state name="distribute document"&gt;
      &lt;transition to="collect feedback" /&gt;
    &lt;/state&gt;
    &lt;state name="collect feedback"&gt;
      &lt;transition to="document finished" /&gt;
    &lt;/state&gt;
    &lt;end name="document finished" /&gt;

    <span class="bold"><strong>&lt;start&gt;
      &lt;transition to="make planning" /&gt;
    &lt;/start&gt;</strong></span>
    &lt;state name="make planning"&gt;
      &lt;transition to="estimate budget" /&gt;
    &lt;/state&gt;
    &lt;state name="estimate budget"&gt;
      &lt;transition to="planning finished" /&gt;
    &lt;/state&gt;
    &lt;end name="planning finished" /&gt;

    &lt;transition to="public project announcement" /&gt;
  &lt;/group&gt;
  
  &lt;state name="public project announcement" /&gt;

&lt;/process&gt;</pre><p>The following scenario will show a scenario in which all 
      wait <code class="literal">state</code> acitivities are signalled in some random
      order till all work is done:  
      </p><pre class="programlisting">ProcessInstance pi = executionService
    .startProcessInstanceByKey("GroupConcurrency");

String documentExecutionId = pi
    .findActiveExecutionIn("distribute document").getId();

String planningExecutionId = pi
    .findActiveExecutionIn("make planning").getId();

pi = executionService.signalExecutionById(documentExecutionId);
assertNotNull(pi.findActiveExecutionIn("collect feedback"));
assertNotNull(pi.findActiveExecutionIn("make planning"));

pi = executionService.signalExecutionById(planningExecutionId);
assertNotNull(pi.findActiveExecutionIn("collect feedback"));
assertNotNull(pi.findActiveExecutionIn("estimate budget"));

pi = executionService.signalExecutionById(planningExecutionId);
assertNotNull(pi.findActiveExecutionIn("collect feedback"));

pi = executionService.signalExecutionById(documentExecutionId);
assertNotNull(pi.findActiveExecutionIn("public project announcement"));</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="groupsecret"/>2.2.5. <code class="literal">group</code> secret</h3></div></div></div><p>Groups also support that you create transitions over group 
      boundaries.  So it's possible to have a tranition from an activity 
      outside the group directly to an activity inside the group without 
      modelling a start activity on the border of the group.  Similarly 
      with transitions from activities inside the group to activities 
      outside the group.  But shhhhhhhhh!
      Don't tell anyone cause this is not BPMN compliant.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="foreach"/>2.3. Multiplicative split with <code class="literal">foreach</code></h2></div></div></div><p>Activity <code class="literal">foreach</code> allows multiple paths of execution
      to be started over a single branch of the process. Its attributes are
      described in the table below.</p><div class="table"><a id="d0e622"/><p class="title"><b>Table 2.3. <code class="literal">foreach</code> attributes:</b></p><div class="table-contents"><table summary="foreach attributes:" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Required?</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">in</code></td><td>expression or text</td><td> </td><td>required</td><td>The collection to be iterated. Each item in the collection spawns a new
            concurrent execution leaving over the default transition. <code class="literal">in</code>
            supports collections of any kind, arrays and comma separated strings.</td></tr><tr><td><code class="literal">var</code></td><td>text</td><td> </td><td>required</td><td>The variable where the current item of the collection is stored.
            This variable is set in the concurrent execution and is visible only to that
            execution.</td></tr></tbody></table></div></div><br class="table-break"/><p>In the example that follows, there is a need to collect reports from
      different departments. The same task is to be performed by different groups.
      This situation is easily modeled with <code class="literal">foreach</code>.
      Process variable <code class="literal">departments</code> provides the group names,
      whereas <code class="literal">quota</code> indicates how many tasks must be completed
      before execution leaves the <code class="literal">join</code> activity.</p><pre class="programlisting">&lt;process name="ForEach" xmlns="http://jbpm.org/4.4/jpdl"&gt;

   &lt;start g="28,61,48,48" name="start1"&gt;
      &lt;transition to="foreach1"/&gt;
   &lt;/start&gt;

   &lt;foreach var="department" in="#{departments}" g="111,60,48,48" name="foreach1"&gt;
      &lt;transition to="Collect reports"/&gt;
   &lt;/foreach&gt;

   &lt;task candidate-groups="#{department}" g="201,58,92,52" name="Collect reports"&gt;
      &lt;transition to="join1"/&gt;
   &lt;/task&gt;

   &lt;join g="343,59,48,48" multiplicity="#{quorum}" name="join1"&gt;
      &lt;transition to="end1"/&gt;
   &lt;/join&gt;

   &lt;end g="433,60,48,48" name="end1"/&gt;

&lt;/process&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>When using foreach, the corresponding join must have the
      multiplicity attribute set. Without it, join continues execution based on its
      incoming transitions. In the preceding example, join has a single incoming transition.
      If multiplicity is not specified, the first execution that reaches the join
      activity will cause the parent execution to leave the join.</p></div><p>Here is how to initialize the iterative process variables.</p><pre class="programlisting">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put("departments", new String[] { "sales-dept", "hr-dept", "finance-dept" });
variables.put("quorum", 3);
ProcessInstance processInstance = executionService.startProcessInstanceByKey("ForEach", variables);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="java"/>2.4. <code class="literal">java</code> activity</h2></div></div></div><p>
      The purpose of the <code class="literal">java</code> activity in general is to invoke
      a Java method as explained in the User Guide. This section in the Developer 
      Guide is specifically about how to use the <code class="literal">java</code> activity
      to invoke a method of an ejb session bean. 
    </p><p>
      Exactly for this purpose it is possible to use the <code class="literal">ejb-jndi-name</code>
      attribute. As its name indicates the attribute specifies the jndi name of the 
      ejb of which the method needs to be invoked. Consider the following ejb:
    </p><pre class="programlisting">package org.jbpm.test.enterprise.stateless.bean;

import javax.ejb.Stateless;

@Stateless
public class CalculatorBean implements CalculatorRemote, CalculatorLocal {

   public Integer add(Integer x, Integer y) {
      return x + y;
   }

   public Integer subtract(Integer x, Integer y) {
      return x - y;
   }
}</pre><p>and the following process definition:</p><div class="figure"><a id="process.java.ejb"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.java.ejb.png" align="middle" alt="The ejb method invocation example process"/></div></div><p class="title"><b>Figure 2.9. The ejb method invocation example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="EJB"&gt;

  &lt;start&gt;
    &lt;transition to="calculate" /&gt;
  &lt;/start&gt;

  <span class="bold"><strong>&lt;java name="calculate" 
        ejb-jndi-name="CalculatorBean/local"
        method="add"
        var="answer"&gt;
        
    &lt;arg&gt;&lt;int value="25"/&gt;&lt;/arg&gt;
    &lt;arg&gt;&lt;int value="38"/&gt;&lt;/arg&gt;
    
    &lt;transition to="wait" /&gt;
  &lt;/java&gt;</strong></span>
  
  &lt;state name="wait" /&gt;

&lt;/process&gt;</pre><p>
      As you can expect, the execution of this node will invoke the <code class="literal">add</code> method of the ejb
      that is known under the jndi name <code class="literal">CalculatorBean/local</code>. The result will be stored in 
      the variable <code class="literal">answer</code>. This is illustrated in the following test snippet.
    </p><pre class="programlisting">public void testEjbInvocation() throws Exception {
  String executionId = executionService
      .startProcessInstanceByKey("EJB")
      .getProcessInstance()
      .getId();
  assertEquals(63, executionService.getVariable(executionId, "answer"));
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="assign"/>2.5. <code class="literal">assign</code></h2></div></div></div><p>The <code class="literal">assign</code> activity retrieves a value and assigns it
    to a target location.</p><div class="table"><a id="d0e746"/><p class="title"><b>Table 2.4. <code class="literal">assign</code> attributes:</b></p><div class="table-contents"><table summary="assign attributes:" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Required?</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">from-var</code></td><td>string</td><td> </td><td rowspan="2">one of <code class="literal">from-var</code>, <code class="literal">from-expr</code>, <code class="literal">from</code> is required</td><td>variable that provides the source value</td></tr><tr><td><code class="literal">from-expr</code></td><td>expression</td><td> </td><td>expression that resolves the source value</td></tr><tr><td><code class="literal">lang</code></td><td>string</td><td>default <span class="bold"><strong>expression</strong></span> language defined in <a href="#">???</a></td><td>optional</td><td>language in which <code class="literal">from-expr</code> is written</td></tr><tr><td><code class="literal">to-var</code></td><td>string</td><td> </td><td rowspan="2">one of <code class="literal">to-var</code>, <code class="literal">to-expr</code> is required</td><td>variable that provides the target location</td></tr><tr><td><code class="literal">to-expr</code></td><td>expression</td><td> </td><td>expression that resolves the target location</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="d0e839"/><p class="title"><b>Table 2.5. <code class="literal">assign</code> elements:</b></p><div class="table-contents"><table summary="assign elements:" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Element</th><th>Multiplicity</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">from</code></td><td>0..1</td><td>descriptor that constructs the source value</td></tr></tbody></table></div></div><br class="table-break"/><p>Every form of <code class="literal">from</code> can be combined with any form
    of <code class="literal">to</code>. The listing below simply assigns a variable to
    another.</p><pre class="programlisting">&lt;assign name='copy' from-var='person' to-var='clone'&gt;
  &lt;transition to='wait' /&gt;
&lt;/assign&gt;</pre><p>The next example shows an expression value being assigned to a
    variable.</p><pre class="programlisting">&lt;assign name='resolve' from-expr='#{person.name}' to-var='name'&gt;
  &lt;transition to='wait' /&gt;
&lt;/assign&gt;</pre><p>Our last example presents a value constructed by a descriptor being
    assigned to the expression location.</p><pre class="programlisting">&lt;assign name='resolve' to-expr='#{person.address.street}'&gt;
  &lt;from&gt;&lt;string value='gasthuisstraat' /&gt;&lt;/from&gt;
  &lt;transition to='wait' /&gt;
&lt;/assign&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="rulesdeployer"/>2.6. Rules deployer</h2></div></div></div><p>The rules deployer is a convenience integration between jBPM and 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://drools.org">Drools</a>.  It creates a KnowledgeBase based 
    on all .drl files that are included in a business archive deployment.
    That KnowledgeBase is then stored in the repository cache.  So one 
    KnowledgeBase is maintained in memory the process-engine-context.  Activities 
    like the <a href="#rulesdecision" title="2.7. rules-decision activity">rules decision</a> leverage 
    this KnowledgeBase. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="rulesdecision"/>2.7. <code class="literal">rules-decision</code> activity</h2></div></div></div><p>A rules-decision is an automatic activity that will select a single outgoing 
    transition based on the evaluation of rules.
    </p><p>Rules for a rules decision are to be deployed as part of the business 
    archive.  Those rules can use all process variables as globals in rule definitions.  
    The <code class="literal">rule-decision</code> activity will use a stateless knowledge 
    session on the knowledgebase.  The execution arriving in the <code class="literal">rules-decision</code>
    is executed on the stateless drools knowledge session. 
    </p><p>Let's look at the next example how that works in practice.  We'll start 
    with the <code class="literal">RulesDecision</code> process</p><div class="figure"><a id="process.rules.decision"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.rules.decision.png" align="middle" alt="The rules decision example process"/></div></div><p class="title"><b>Figure 2.10. The rules decision example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="RulesDecision"&gt;

  &lt;start&gt;
    &lt;transition to="isImportant" /&gt;
  &lt;/start&gt;

  <span class="bold"><strong>&lt;rules-decision name="isImportant"&gt;
    &lt;transition name="dunno" to="analyseManually" /&gt;
    &lt;transition name="important" to="processWithPriority" /&gt;
    &lt;transition name="irrelevant" to="processWhenResourcesAvailable" /&gt;
  &lt;/rules-decision&gt;</strong></span>

  &lt;state name="analyseManually" /&gt;
  &lt;state name="processWithPriority" /&gt;
  &lt;state name="processWhenResourcesAvailable" /&gt;

&lt;/process&gt;</pre><p>The following <code class="literal">isImportant.drl</code> is included in the 
   business archive deployment.
   </p><pre class="programlisting">global java.lang.Integer amount;
global java.lang.String product;
global org.jbpm.jpdl.internal.rules.Outcome outcome;

rule "LessThen3IsIrrelevant"
  when
    eval(amount &lt; 3)
  then 
    outcome.set("irrelevant");
end

rule "MoreThen24IsImportant"
  when
    eval(amount &gt; 24)
  then 
    outcome.set("important");
end

rule "TwelveTempranillosIsImportant"
  when
    eval(product == "Tempranillo")
    eval(amount &gt; 12)
  then 
    outcome.set("important");
end</pre><p>First you see that amount and product are defined as globals.  
    Those will resolve by the <code class="literal">rules-decision</code> to the 
    process variables with those respective names.
    </p><p><code class="literal">outcome</code> is a special global variable that is 
    used to indicate the transition to take in the consequence.  Also, 
    if no outcome is specified by the rules, the default transition will be taken.
    </p><p>So let's start a new process instance and set 2 variables 
    <code class="literal">product</code> and <code class="literal">amount</code> with respective 
    values <code class="literal">shoe</code> and <code class="literal">32</code>:</p><pre class="programlisting">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put("amount", 32);
variables.put("product", "shoe");

ProcessInstance processInstance = 
    executionService.startProcessInstanceByKey("RulesDecision", variables);</pre><p>After starting the process instance method returns, the process instance 
    will have arrived in the activity <code class="literal">processWithPriority</code> </p><p>In similar style, a new RulesDecision process instance with 
    <code class="literal">2 missiles</code> will go to 
    activity <code class="literal">processWhenResourcesAvailable</code> </p><p>A RulesDecision process instance with 
    <code class="literal">15 shoes</code> will go to 
    activity <code class="literal">analyseManually</code> </p><p>And a RulesDecision process instance with 
    <code class="literal">13 Tempranillo</code>s will go to 
    activity <code class="literal">analyseManually</code> </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="rules"/>2.8. <code class="literal">rules</code> activity</h2></div></div></div><p>A <code class="literal">rules</code> is an automatic activity that will 
    create a stateful knowledge session, feed a number of facts in it and 
    fire all rules.  The idea is that the rules will update or create 
    process variables that will be used later in the process.  Facts 
    can be specified as sub elements of the rules activity.
    </p><div class="table"><a id="d0e996"/><p class="title"><b>Table 2.6. <code class="literal">rules</code> elements:</b></p><div class="table-contents"><table summary="rules elements:" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Element</th><th>Multiplicity</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">fact</code></td><td>0..*</td><td>A fact that will be fed into the stateful rule session.
            </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="d0e1019"/><p class="title"><b>Table 2.7. <code class="literal">fact</code> attributes:</b></p><div class="table-contents"><table summary="fact attributes:" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Required?</th><th>Description</th></tr></thead><tbody><tr><td>var</td><td>variable name</td><td> </td><td>either <code class="literal">var</code> or <code class="literal">expr</code> is required</td><td>the variable name for which the value should be inserted as a fact.  
            </td></tr><tr><td>expr</td><td>expression</td><td> </td><td>either <code class="literal">var</code> or <code class="literal">expr</code> is required</td><td>the expression for which the resulting value should be inserted as a fact.  
            </td></tr></tbody></table></div></div><br class="table-break"/><p>If a rules activity has one outgoing transition, then that one is 
    taken automatically.  But multiple outgoing transitions can be specified
    with conditions on them, just like with the <code class="literal">decision</code> activity
    when using the conditions. 
    </p><p>For example:</p><div class="figure"><a id="process.rules"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.rules.png" align="middle" alt="The rules example process"/></div></div><p class="title"><b>Figure 2.11. The rules example process</b></p></div><br class="figure-break"/><pre class="programlisting">&lt;process name="Rules"&gt;

  &lt;start&gt;
    &lt;transition to="evaluateStatus"/&gt;
  &lt;/start&gt;

  <span class="bold"><strong>&lt;rules name="evaluateStatus"&gt;
    &lt;fact var="room" /&gt;
    &lt;transition to="checkForFires"/&gt;
  &lt;/rules&gt;</strong></span>

  &lt;decision name="checkForFires"&gt;
    &lt;transition to="getFireExtinguisher"&gt;
      &lt;condition expr="#{room.onFire}" /&gt;
    &lt;/transition&gt;
    &lt;transition to="goToPub"/&gt;
  &lt;/decision&gt;

  &lt;state name="getFireExtinguisher"/&gt;
  &lt;state name="goToPub"/&gt;

&lt;/process&gt;</pre><p>The process first checks with rules if the room is on fire.
    The Room class looks like this:</p><pre class="programlisting">public class Room implements Serializable {

  int temperature = 21; 
  boolean smoke = false;
  boolean isOnFire = false;
  
  public Room(int temperature, boolean smoke) {
    this.temperature = temperature;
    this.smoke = smoke;
  }
  
  ...getters and setters...
}</pre><p>Following rules are deployed in the same business archive:</p><pre class="programlisting">rule "CheckRoomOnFire"
  when
    room : org.jbpm.examples.rules.Room( temperature &gt; 30, smoke == true )
  then 
    room.setOnFire( true );
end</pre><p>So when a new <code class="literal">Rules</code> process instance is started 
   like this:</p><pre class="programlisting">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put("room", new Room(350, true));

ProcessInstance processInstance = 
    executionService.startProcessInstanceByKey("Rules", variables);</pre><p>Then the process will end up in the activity <code class="literal">getFireExtinguisher</code>
    </p><p>And when the process is started with a Room(21, false), it will end up in the 
    activity <code class="literal">goToPub</code>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="jms"/>2.9. <code class="literal">jms</code> activity</h2></div></div></div><p>Disclaimer: this activity is not yet stable.  Two aspects will be revisisted 
    in following releases:</p><div class="itemizedlist"><ul><li>Binding the non-xa use of JMS to the standard transaction</li><li>We're still figuring out why in JBoss the java:JmsXA connection
    factory doesn't implement XAConnectionFactory.  And that we have to use the 
    non-XA JMS API's for sending and retrieving messages.  That is why we've 
    put <code class="literal">transacted="false"</code> in our enterprise QA run processes 
    (used for docs here).  And that is why we use method <code class="literal">jmsConsumeMessageFromQueue("java:JmsXA", "queue/jbpm-test-queue", 1000, false, Session.AUTO_ACKNOWLEDGE);</code>
    in our test cases that run on JBoss (also used in docs here)</li></ul></div><p>
      The <code class="literal">jms</code> activity provides users with convenience for sending JMS messages. 
      At this moment the sending of three different types of JMS messages is possible: text, object 
      and map. Specifying message properties is not yet supported.
    </p><div class="table"><a id="d0e1137"/><p class="title"><b>Table 2.8. <code class="literal">jms</code> attributes:</b></p><div class="table-contents"><table summary="jms attributes:" border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Required?</th><th>Description</th></tr></thead><tbody><tr><td>connection-factory</td><td>jndi name</td><td> </td><td><span class="bold"><strong>required</strong></span></td><td>the JNDI name of the jms connection factory.  
            </td></tr><tr><td>destination</td><td>jndi name</td><td> </td><td><span class="bold"><strong>required</strong></span></td><td>the JNDI name of the jms queue or topic.  
            </td></tr><tr><td>transacted</td><td>boolean: {true, false}</td><td>true</td><td>optional</td><td>Specifies if JMS message send should happen transactional.
            @see QueueConnection.createQueueSession(boolean transactional, int acknowledgeMode)  
            </td></tr><tr><td>acknowledge</td><td>{ auto | client | dups-ok }</td><td>auto</td><td>optional</td><td>Specifies the acknowledge mode
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/javaee/5/docs/api/javax/jms/QueueConnection.html#createQueueSession(boolean,%20int)">@see QueueConnection.createQueueSession(boolean transactional, int acknowledgeMode)</a>  
            </td></tr></tbody></table></div></div><br class="table-break"/><p>There are 3 types of JMS messages that you can send to to the destination: text, object 
      and map.  The <code class="literal">connection-factory</code> and <code class="literal">destination</code> attributes are 
      mandatory and respectively contain the names of the connection factory and destination (queue or topic) 
      that will be used to lookup the corresponding objects in JNDI.   The lookup is done like this:
    </p><pre class="programlisting">InitialContext initialContext = new InitialContext();
Destination destination = (Destination) initialContext.lookup(destinationName);
Object connectionFactory = initialContext.lookup(connectionFactoryName);</pre><p>The <code class="literal">jms</code> activity will use the JMS queue apis if the destination 
    is an <code class="literal">instanceof</code> Queue.  Analogue for topics. 
    </p><p>The <code class="literal">jms</code> activity will use the XA JMS apis if the connectionFactory 
    is an <code class="literal">instanceof</code> XAConnectionFactory.  Analogue for plain ConnectionFactory's. 
    </p><p>So if you're running inside an appserver, then the <code class="literal">new InitialContext()</code> 
    will see the queue's and topics configured in the appserver.</p><p>When your're using the JMS mocking 
    in standalone test mode, then the queues and topics that you created with <code class="literal">JbpmTestCase.jmsCreateQueue</code>  
    and <code class="literal">JbpmTestCase.jmsCreateTopic</code> will be available.</p><p>When you're running as a remote application client, then you have to 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/products/jndi/tutorial/beyond/env/source.html">specify 
    the jndi environment with system properties</a>.</p><div class="table"><a id="d0e1247"/><p class="title"><b>Table 2.9. <code class="literal">jms</code> elements:</b></p><div class="table-contents"><table summary="jms elements:" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Element</th><th>Multiplicity</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">text</code></td><td>0..1</td><td>A string of text that will be used as payload for the JMS message.
            </td></tr><tr><td><code class="literal">object</code></td><td>0..1</td><td>A serializable object that will be used as payload for the JMS message.
            </td></tr><tr><td><code class="literal">map</code></td><td>0..1</td><td>A map of which the key-value entries will be used as payload for the JMS message.
            </td></tr></tbody></table></div></div><br class="table-break"/><p>
      Exactly one of the elements <code class="literal">text</code>, <code class="literal">object</code> or <code class="literal">map</code>
      is mandatory. The presence of this element will determine the kind of message that will be sent to the 
      queue obtained in the lookup mentioned above. This message will be a <code class="literal">TextMessage</code>, 
      <code class="literal">ObjectMessage</code> or <code class="literal">MapMessage</code> respectively.
    </p><p>
      In the following subsections the different types of supported messages will be explained. The used process
      is in the three cases similar. The graphical representation of the process is shown below. 
    </p><div class="mediaobject" align="center"><img src="images/process.jms.png" align="middle"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="mockjmsproviderforeasytesting"/>2.9.1. Mock JMS provider for easy testing</h3></div></div></div><p>Apart from configuring a real JMS and making sure it is available in JNDI, 
      a <code class="literal">jms</code> activity can also be tested with a mock JMS provider.
      That might be easier to perform scenario testing of your process.</p><p>Following test helper methods are based solely on plain JMS apis and hence they work in 
      a standalone environment as well as in an appserver environment:</p><div class="itemizedlist"><ul><li>JbpmTestCase.jmsConsumeMessageFromQueue(String connectionFactoryJndiName, String queueJndiName) 
          with defaults 1000, true, Session.AUTO_ACKNOWLEDGE for parameters timeout, transacted and acknowledgeMode respectively</li><li>JbpmTestCase.jmsConsumeMessageFromQueue(String connectionFactoryJndiName, String queueJndiName, long timeout, boolean transacted, int acknowledgeMode)</li><li>JbpmTestCase.jmsConsumeMessageFromQueueXA(String connectionFactoryJndiName, String queueJndiName, long timeout)</li><li>JbpmTestCase.jmsAssertQueueEmpty(String connectionFactoryJndiName, String queueJndiName, long timeout, boolean transacted, int acknowledgeMode)</li><li>JbpmTestCase.jmsAssertQueueEmptyXA(String connectionFactoryJndiName, String queueJndiName, long timeout)</li><li>JbpmTestCase.jmsStartTopicListener(String connectionFactoryJndiName, String topicJndiName, boolean transacted, int acknowledgeMode)</li><li>JbpmTestCase.jmsStartTopicListenerXA(String connectionFactoryJndiName, String topicJndiName)</li><li>JmsTopicListener.getNextMesssage(long timeout)</li><li>JmsTopicListener.stop()</li></ul></div><p>For example, after the process execution has executed the <code class="literal">jms</code> activity, 
      messages can be asserted like this:</p><pre class="programlisting">MapMessage mapMessage = (MapMessage) 
  jmsConsumeMessageFromQueue("java:/JmsXA", "queue/ProductQueue");
assertEquals("shampoo", mapMessage.getString("product"));</pre><p>The following jms helper methods are based on mockrunner and hence they only work in a standalone 
      environment:</p><p>(we're collaborating with mockrunner people to have these methods also work in an appserver environment)</p><div class="itemizedlist"><ul><li>void jmsCreateQueue(String connectionFactoryJndiName, String queueJndiName)</li><li>void jmsRemoveQueue(String connectionFactoryJndiName, String queueJndiName)</li><li>void jmsCreateTopic(String connectionFactoryJndiName, String topicJndiName)</li><li>void jmsRemoveTopic(String connectionFactoryJndiName, String topicJndiName)</li></ul></div><p>For example, a queue can be created and removed in the setup and tearDown methods of a test like this:</p><pre class="programlisting">protected void setUp() throws Exception {
  super.setUp();
  jmsCreateQueue("java:/JmsXA", "queue/ProductQueue");
}

protected void tearDown() throws Exception {
  jmsRemoveQueue("java:/JmsXA", "queue/ProductQueue");
  super.tearDown();
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="testmessages"/>2.9.2. Text messages</h3></div></div></div><p>
        The first possibility of sending JMS messages is to use text as its payload. In this case a JMS
        <code class="literal">TextMessage</code> will be created and sent to the specified destination.
        Consider the following process definition:
      </p><pre class="programlisting">&lt;process name="JmsQueueText"&gt;

  &lt;start&gt;
    &lt;transition to="send message"/&gt;
  &lt;/start&gt;

  <span class="bold"><strong>&lt;jms name="send message"
       connection-factory="java:JmsXA"
       destination="queue/jbpm-test-queue"
       transacted="false"&gt;
    &lt;text&gt;This is the body&lt;/text&gt;
    &lt;transition to="wait"/&gt;
  &lt;/jms&gt;</strong></span>

  &lt;state name="wait"/&gt;

&lt;/process&gt;</pre><p>
        As you may expect and as is shown in the following test case starting this process will cause
        the JMS node to send a message to the queue with the name "queue/jbpm-test-queue".
        The factory used to create a connection to connect to this queue is named "java:JmsXA".
        The payload of the message is the text string "This is the body".
      </p><pre class="programlisting">executionService.startProcessInstanceByKey("JmsQueueText");

TextMessage textMessage = (TextMessage) 
  jmsConsumeMessageFromQueue("java:JmsXA", "queue/jbpm-test-queue", 1000, false, Session.AUTO_ACKNOWLEDGE);
assertEquals("This is the body", textMessage.getText());</pre><p>
        The relevant code is shown above in boldface. The rest of the method is boilerplate code needed to
        setup a message consumer. We will omit this code in the subsequent examples.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="objectmessages"/>2.9.3. Object messages</h3></div></div></div><p>
        The second possibility is to use a serializable object as the payload of the message. In this case a
        JMS <code class="literal">ObjectMessage</code> will be created and sent to the specified destination.
        Consider the following process definition:
      </p><pre class="programlisting">&lt;process name="JmsQueueObject"&gt;

  &lt;start&gt;
    &lt;transition to="send message"/&gt;
  &lt;/start&gt;

  <span class="bold"><strong>&lt;jms name="send message"
       connection-factory="java:JmsXA"
       destination="queue/jbpm-test-queue"
       transacted="false"&gt;
    &lt;object expr="${object}"/&gt;
    &lt;transition to="wait"/&gt;
  &lt;/jms&gt;</strong></span>

  &lt;state name="wait"/&gt;

&lt;/process&gt;</pre><p>
        As in the previous case a message will be sent to the queue with the name "queue/jbpm-test-queue".
        Also again a factory used to create a connection to connect to this queue is named "java:JmsXA".
        But in this case the payload of the message is the serializable object that is obtained by 
        evaluating the expression specified by the <code class="literal">expr</code> attribute. This is illustrated in the test case below.
      </p><pre class="programlisting">Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put("object", "this is the object");
executionService.startProcessInstanceByKey("JmsQueueObject", variables);

ObjectMessage objectMessage = (ObjectMessage) 
  jmsConsumeMessageFromQueue("java:JmsXA", "queue/jbpm-test-queue", 1000, false, Session.AUTO_ACKNOWLEDGE);
assertEquals("this is the object", objectMessage.getObject());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="mapmessages"/>2.9.4. Map messages</h3></div></div></div><p>
        In this third possibility the payload is constituted by the key-value entries of a map. This time a
        JMS <code class="literal">MapMessage</code> will be created and sent to the specified destination.
        Consider the following process definition:
      </p><pre class="programlisting">&lt;process name="JmsQueueMap"&gt;

  &lt;start&gt;
    &lt;transition to="send message"/&gt;
  &lt;/start&gt;

  <span class="bold"><strong>&lt;jms name="send message"
       connection-factory="java:JmsXA"
       destination="queue/jbpm-test-queue"
       transacted="false"&gt;
    &lt;map&gt;
      &lt;entry&gt;
        &lt;key&gt;&lt;string value="x"/&gt;&lt;/key&gt;
        &lt;value&gt;&lt;string value="foo"/&gt;&lt;/value&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
    &lt;transition to="wait"/&gt;
  &lt;/jms&gt;</strong></span>

  &lt;state name="wait"/&gt;

&lt;/process&gt;</pre><p>
        Again a message will be sent to the queue with the name "queue/jbpm-test-queue" and the 
        factory used to create a connection to connect to this queue is named "java:JmsXA".
        In this case the payload of the message are the specified key-value pairs of the map. 
        It is illustrated in the test case below.
      </p><pre class="programlisting">executionService.startProcessInstanceByKey("JmsQueueMap");

MapMessage mapMessage = (MapMessage) 
  jmsConsumeMessageFromQueue("java:JmsXA", "queue/jbpm-test-queue", 1000, false, Session.AUTO_ACKNOWLEDGE);
assertTrue(mapMessage.itemExists("x"));
assertEquals("foo", mapMessage.getObject("x"));</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1420"/>2.10. History session chain</h2></div></div></div><p>
  	  The <span class="bold"><strong>history session</strong></span>, which can be added to the 
  	  <span class="italic">transaction-context</span> in the jBPM configuration will
  	  add a default history event listener to the process engine. This default history session
  	  will write the information in the history events to the history tables in the database.
    </p><p>
  	  The <span class="bold"><strong>history session chain</strong></span> construct allows to define custom
  	  history event listeners. These custom history sessions will be called when a history event
  	  is fired. Multiple custom implementations are possible as follows:
  	  </p><pre class="programlisting">
&lt;transaction-context&gt;
    &lt;history-sessions&gt;
      &lt;object class="org.jbpm.test.historysessionchain.MyProcessStartListener" /&gt;
      &lt;object class="org.jbpm.test.historysessionchain.MyProcessEndListener" /&gt;
    &lt;/history-sessions&gt;
  &lt;/transaction-context&gt;  	  
  	  </pre><p>
  	  The custom history sessions must be on the classpath when the jBPM configuration is parsed
  	  and they must implement the <span class="bold"><strong>HistorySession</strong></span> interface.
  	  </p><pre class="programlisting">
public class MyProcessStartListener implements HistorySession {
  
  public void process(HistoryEvent historyEvent) {
    if (historyEvent instanceof ProcessInstanceCreate) {
      ...
    }
  }

}  	  
  	  </pre><p>
  	</p>
  	If you want to add the default history session implementation to your configuration, add the 
  	following line to the transaction-context section:
  	<pre class="programlisting">
&lt;history-sessions&gt;
      &lt;object class="org.jbpm.pvm.internal.history.HistorySessionImpl" /&gt;
&lt;/history-sessions&gt;  	
  	</pre>
  	If you are using the <span class="bold"><strong>jbpm.default.cfg.xml</strong></span> import in your
  	configuration, this default history session implementation is already configured as above.
  </div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1452"/>2.11. Creating identity groups</h2></div></div></div><p>The identity service methods to create groups are based on 
    component generated ID's.
    </p><pre class="programlisting">public class IdentityService {
  /** create a group new group 
   * @return the generated id for this group. */
  String createGroup(String groupName);

  /** create a group new group 
   * @return the generated id for this group. */
  String createGroup(String groupName, String groupType);

  /** create a group new group 
   * @return the generated id for this group. */
  String createGroup(String groupName, String groupType, String parentGroupId);
  
  ...

}</pre><p>In the next release we might switch to user provided ID's for these 3 methods.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="taskforms"/>2.12. Task forms</h2></div></div></div><p>
      Human interaction happens nowadays most of the times through web interfaces
      using some kind of form to capture input of the user. Using jBPM
      task forms, a process designer can attach such input forms to a 
      <span class="bold"><strong>task activity</strong></span> or a <span class="bold"><strong>
      start activity</strong></span>. When using the jBPM console, the forms will
      automatically be displayed for user input when a process instance is started
      or when a task is completed. An example process (<code class="literal">VacationRequest</code>)
      is shipped with the default examples of the distribution demo.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taskformsusage"/>2.12.1. Usage</h3></div></div></div><p>
        Task form references can be put on start and task activities:
        </p><pre class="programlisting">
&lt;start <span class="bold"><strong>form="org/jbpm/examples/taskform/request_vacation.ftl"</strong></span> name="start"&gt;
  &lt;transition to="verify_request"/&gt;
&lt;/start&gt;
&lt;task candidate-users="mike,peter" <span class="bold"><strong>form="org/jbpm/examples/taskform/verify_request.ftl"</strong></span> name="verify_request"&gt;
  &lt;transition name="reject" to="vacation_rejected"/&gt;
  &lt;transition name="accept" to="vacation_accepted"/&gt;
&lt;/task&gt;
        </pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taskformsformat"/>2.12.2. Form format</h3></div></div></div><p>
        Task forms are plain text files containing arbitray content. However,
        when using the jBPM console, HTML pages containing a form element
        are required. The default form plugin of the console leverages the 
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://freemarker.sourceforge.net/">freemarker</a>
        templating library. It builds on the following constraints:
        </p><div class="itemizedlist"><ul><li>Templates need to be suffixed *.ftl and be included with the deployment:
            <pre class="programlisting">deployment.addResourceFromClasspath("org/jbpm/examples/taskform/verify_request.ftl");</pre></li><li>The action of the form must be "${form.action}"</li><li>HTML forms need to provide the correct enctype: "multipart/form-data"</li><li>Form field names become process variables names and vice versa</li><li>A reserved field name is available for signaling execution upon task completion: "outcome"</li></ul></div><p>
        
        </p><pre class="programlisting">
&lt;html&gt;
  &lt;body&gt;
    &lt;form action="${form.action}" method="POST" enctype="multipart/form-data"&gt;
      &lt;h3&gt;Your employee, ${employee_name} would like to go on vacation&lt;/h3&gt;
      Number of days: ${number_of_days}&lt;br/&gt;
      &lt;hr&gt;
      In case you reject, please provide a reason:&lt;br/&gt;
      &lt;input type="textarea" name="reason"/&gt;&lt;br/&gt;
      &lt;#list outcome.values as transition&gt;
          &lt;input type="submit" name="outcome" value="${transition}"&gt;
      &lt;/#list&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre><p>
        In this example, the process variables <code class="literal">employee_name</code>
        and <code class="literal">number_of_days</code> is displayed on the 
        screen using a variable reference expression. The value of the input
        field <code class="literal">reason</code> will be stored as a process
        variable.
      </p><p>
        The jBPM console will render the taskforms automatically:
        </p><div class="mediaobject" align="center"><img src="images/taskform_example.png" align="middle"/></div><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="instancemigration"/>2.13. Instance Migration</h2></div></div></div><p>By default the behaviour of jBPM upon redeployment is to start new process instances with the newly deployed version.
   	Also, it is possible to start new process instances using a specified older version if needed. The existing running 
   	process instances always keep running following the definition that they were started in. But what when a customer 
   	or some piece of legislation mandates that this behaviour is not enough? We could e.g. think of a situation where
   	process instances do not make sense anymore when a new definition is deployed. In this case these instances should be
   	ended. In another situation it might be needed that all (or even some particular) instances are migrated and moved 
   	to the newly deployed definition. jBPM contains a tool that exactly supports these use cases.</p><p>Before delving into the details of the instance migration tool, we have to warn the reader. Though we did a 
   	reasonable attempt at trying to understand the different use cases, there are certainly a number of situations that 
   	are not yet covered. For now we have concentrated on the limited case where the nodes that are involved in the 
   	migration are states. The goal is to expand this support to other nodes (e.g. human tasks) in the future.
   	We welcome any feedback around these use cases very eagerly.</p><p>For all the examples that follow, we will start from the same original process definition:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  &lt;start&gt;
    &lt;transition to="a"/&gt;
  &lt;/start&gt;
  &lt;state name="a"&gt;
    &lt;transition to="b"&gt;
  &lt;/state&gt;
  &lt;state name="b"&gt;
    &lt;transition to="c"/&gt;
  &lt;/state&gt;
  &lt;state name="c"&gt;
    &lt;transition to="end"/&gt;
  &lt;/state&gt;
  &lt;end name="end"/&gt;
&lt;/process&gt;
   	  </pre><p>
   	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1541"/>2.13.1. Simple Migration</h3></div></div></div><p>The first obvious use case that we wanted to cover is where a new version of a process is deployed for
      which one of the following statements is true:
        </p><div class="itemizedlist"><ul><li>the structure of the process is completely the same and all the nodes have the same name</li><li>only new nodes have been added but all the nodes from the previous definition still exist</li></ul></div><p>
      This use case might be useful if for instance event handler names change between versions, if new processing
      has to be inserted or if new paths of execution have to be added. Consider the following modification of the
      above process definition to indicate that running instances have to be migrated:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  &lt;start&gt;
    &lt;transition to="a"/&gt;
  &lt;/start&gt;
  &lt;state name="a"&gt;
    &lt;transition to="b"&gt;
  &lt;/state&gt;
  &lt;state name="b"&gt;
    &lt;transition to="c"/&gt;
  &lt;/state&gt;
  &lt;state name="c"&gt;
    &lt;transition to="end"/&gt;
  &lt;/state&gt;
  &lt;end name="end"/&gt;
  &lt;migrate-instances/&gt;
&lt;/process&gt;
   	  </pre><p>
   	  When this second process is deployed the running instances of the previous version - and only of the previous
   	  version - will be migrated to the new version. We"ll explain later what to do if you want more than only the
   	  instances of the previous version to be migrated. Assume that when deploying the second version there would
   	  be one process instance in the state "a" and one process instance in the state "b". The following snippet 
   	  in a unit test would be valid:
   	  </p><pre class="programlisting">
    ProcessDefinition pd1 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi1 = startAndSignal(pd1, "a");
    ProcessInstance pi2 = startAndSignal(pd1, "b");
    ProcessDefinition pd2 = deployProcessDefinition("foobar", versionWithSimpleMigration);
    pi1 = executionService.findProcessInstanceById(pi1.getId());
    pi2 = executionService.findProcessInstanceById(pi2.getId());
    assertEquals(pd2.getId(), pi1.getProcessDefinitionId());
    assertEquals(pd2.getId(), pi2.getProcessDefinitionId());
    assertEquals(pi1, pi1.findActiveExecutionIn("a"));
    assertEquals(pi2, pi2.findActiveExecutionIn("b"));
   	  </pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1558"/>2.13.2. Ending Running Instances</h3></div></div></div><p>The second use case is when the instances of the previous process definition have to be ended. 
   	  The way to indicate this would be to add the action attribute to the migrate-instances tag with the
   	  value of "end".
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  ...
  &lt;migrate-instances action="end"/&gt;
&lt;/process&gt;
   	  </pre><p>
   	  If we take the situation from above with one process in state "a" and another in state "b" 
   	  the two processes would be ended as can be seen in the following snippet:
   	  </p><pre class="programlisting">
    ProcessDefinition pd1 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi1 = startAndSignal(pd1, "a");
    ProcessInstance pi2 = startAndSignal(pd1, "b");
    ProcessDefinition pd2 = deployProcessDefinition("foobar", versionWithSimpleAbortion);
    pi1 = executionService.findProcessInstanceById(pi1.getId());
    pi2 = executionService.findProcessInstanceById(pi2.getId());
    assertNull(pi1);
    assertNull(pi2);
   	  </pre><p>
   	  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1569"/>2.13.3. Version Ranges</h3></div></div></div><p>So we've showed you how instances of the previously deployed version - and only that one -
   	  could be either migrated or ended. But what to do when you want to perform these actions on process
   	  instances of other already deployed versions. This can be done by making use of the versions attribute
   	  of the migrate-instances tag. This attribute lets you specify a range of versions that need to be
   	  migrated (or ended). Consider the following process definition:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  &lt;start&gt;
    &lt;transition to="a"/&gt;
  &lt;/start&gt;
  &lt;state name="a"&gt;
    &lt;transition to="b"&gt;
  &lt;/state&gt;
  &lt;state name="b"&gt;
    &lt;transition to="c"/&gt;
  &lt;/state&gt;
  &lt;state name="c"&gt;
    &lt;transition to="end"/&gt;
  &lt;/state&gt;
  &lt;end name="end"/&gt;
  &lt;migrate-instances versions="2..3"/&gt;
&lt;/process&gt;
   	  </pre><p>
   	  Imagine a situation where we would deploy the original process definition 4 times in a row and for each
   	  deployment start a process instance that waits in state "a". Then we deploy the above version
   	  of the process definition with instance migration. The result will be that instance 2 and instance 3 
   	  will be migrated while instance 1 and instance 4 will keep running following their original definition.
   	  This is shown in the snippet below:
   	  </p><pre class="programlisting">
    ProcessDefinition pd1 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi1 = startAndSignal(pd1, "a");
    ProcessDefinition pd2 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi2 = startAndSignal(pd2, "a");
    ProcessDefinition pd3 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi3 = startAndSignal(pd3, "a");
    ProcessDefinition pd4 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi4 = startAndSignal(pd4, "a");
    ProcessDefinition pd5 = deployProcessDefinition("foobar", versionWithAbsoluteVersionRange);
    pi1 = executionService.findProcessInstanceById(pi1.getId());
    pi2 = executionService.findProcessInstanceById(pi2.getId());
    pi3 = executionService.findProcessInstanceById(pi3.getId());
    pi4 = executionService.findProcessInstanceById(pi4.getId());
    assertEquals(pd1.getId(), pi1.getProcessDefinitionId());
    assertEquals(pd5.getId(), pi2.getProcessDefinitionId());
    assertEquals(pd5.getId(), pi3.getProcessDefinitionId());
    assertEquals(pd4.getId(), pi4.getProcessDefinitionId());
   	  </pre><p> 
   	  A number of variants exist for the versions attribute. The example above uses an absolute version range.
   	  It is also possible to use an expression of the form x-n to indicate a version number relative to the 
   	  last deployed version. So if you want to only migrate instances from the last two versions you could 
   	  use the following expression for the versions attribute:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  ...
  &lt;migrate-instances versions="x-2..x"/&gt;
&lt;/process&gt;
   	  </pre><p>
   	  You can also mix and match the absolute and the relative specifications. E.g. if you would like to 
   	  migrate all the instances of all the versions to the newly deployed version you can use the following:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  ...
  &lt;migrate-instances versions="1..x"/&gt;
&lt;/process&gt;
   	  </pre><p>
   	  And for this last example you can also use the "*" wildcard notation:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  ...
  &lt;migrate-instances versions="*"/&gt;
&lt;/process&gt;
   	  </pre><p>
   	  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1589"/>2.13.4. Activity Mappings</h3></div></div></div><p>In some cases users will want to map nodes from the previously deployed process definition to
   	  nodes of the newly deployed process definition. This could be the case when in the newly deployed process
   	  definition some nodes are deleted or have been replaced by nodes with a different name. To support
   	  this use case it is possible to specify so-called activity-mapping elements. These elements have
   	  two attributes: the activity name in the old process definition and the activity name in the new
   	  process definition. Consider the following process definition:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  &lt;start&gt;
    &lt;transition to="a"/&gt;
  &lt;/start&gt;
  &lt;state name="a"&gt;
    &lt;transition to="b"&gt;
  &lt;/state&gt;
  &lt;state name="b"&gt;
    &lt;transition to="c"/&gt;
  &lt;/state&gt;
  &lt;state name="c"&gt;
    &lt;transition to="d"/&gt;
  &lt;/state&gt;
  &lt;state name="d"&gt;
    &lt;transition to="end"/&gt;
  &lt;/state&gt;
  &lt;end name="end"/&gt;
  &lt;migrate-instances&gt;
    &lt;activity-mapping old-name="b" new-name="a"/&gt;
    &lt;activity-mapping old-name="c" new-name="d"/&gt;
  &lt;/migrate-instances&gt;
&lt;/process&gt;
   	  </pre><p>
   	  Deploying this process will put all the instances of the previously deployed process that are waiting
   	  in the state "b" into the state "a" of the newly deployed process. Likewise all 
   	  instances of the previously deployed process definition that are waiting in state "c" will be 
   	  placed in the state "d". The following piece of code illustrates this:
   	  </p><pre class="programlisting">
    ProcessDefinition pd1 = deployProcessDefinition("foobar", originalVersion);
    ProcessInstance pi1 = startAndSignal(pd1, "a");
    ProcessInstance pi2 = startAndSignal(pd1, "b");
    ProcessInstance pi3 = startAndSignal(pd1, "c");
    ProcessDefinition pd2 = deployProcessDefinition("foobar", versionWithCorrectMappings);
    pi1 = executionService.findProcessInstanceById(pi1.getId());
    pi2 = executionService.findProcessInstanceById(pi2.getId());
    pi3 = executionService.findProcessInstanceById(pi3.getId());
    assertEquals(pd2.getId(), pi1.getProcessDefinitionId());
    assertEquals(pd2.getId(), pi2.getProcessDefinitionId());
    assertEquals(pd2.getId(), pi3.getProcessDefinitionId());
    assertEquals(pi1, pi1.findActiveExecutionIn("a"));
    assertEquals(pi2, pi2.findActiveExecutionIn("a"));
    assertEquals(pi3, pi3.findActiveExecutionIn("d"));
    pi1 = executionService.signalExecutionById(pi1.getId());
    pi2 = executionService.signalExecutionById(pi2.getId());
    pi2 = executionService.signalExecutionById(pi2.getId());
    pi3 = executionService.signalExecutionById(pi3.getId());
    assertEquals(pi1, pi1.findActiveExecutionIn("b"));
    assertEquals(pi2, pi2.findActiveExecutionIn("c"));
    assertTrue(pi3.isEnded());
   	  </pre><p>
   	  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1600"/>2.13.5. Migration Handlers</h3></div></div></div><p>We already mentioned that there are a lot of use cases that we probably didn't think of or for
   	  which there was not enough time to build support. Exactly for this reason we provide the concept of 
   	  a migration handler. This is a user defined piece of code that implements the interface 
   	  "org.jbpm.pvm.internal.migration.MigrationHandler":
   	  </p><pre class="programlisting">
public interface MigrationHandler {  

  void migrateInstance(
          ProcessDefinition newProcessDefinition, 
          ProcessInstance processInstance,
          MigrationDescriptor migrationDescriptor);

}
   	  </pre><p>
   	  This migration handler can be specified in the process definition xml and will be executed for each 
   	  process instance that has to be migrated. Experienced users can use this to do all kinds of bookkeeping
   	  they need to do when migrating (or ending) process instances. To perform this bookkeeping, it gets 
   	  of course a handle to the process instance that needs to be migrated, but also to the new process 
   	  definition and to a so called migration descriptor that contains among others the migration mapping.
   	  Take e.g. the following example:
   	  </p><pre class="programlisting">
&lt;process name="foobar"&gt;
  ...
  &lt;migrate-instances&gt;
    &lt;migration-handler class="org.jbpm.test.migration.TestHandler"/&gt;
  &lt;/migrate-instances&gt;
&lt;/process&gt;
   	  </pre><p>
   	  In this case the specified migration handler will be executed for each process instance that needs to
   	  be migrated AFTER the default migration has been done. If the attribute action is set to "end"
   	  the migration handler will be called BEFORE the process instance is ended. If more than one migration
   	  handler is specified, they will be executed one after another.
   	  </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1611"/>2.14. User object caching</h2></div></div></div><p>As indicated in section "User code" in the Users guide, instantiated user objects 
    are by default cached as part of the process definition.  So the single user object will 
    be used to serve all requests.  So you have to make sure that when your user code is used, 
    that it doesn't change the member fields of the user object.  In that case it will be safe
    for your user object to be used by all threads/requests.  This is also called stateless 
    user objects.</p><p>In case you do have a need for stateful user objects, you can specify 
    parameter <code class="literal">cache="disabled"</code> on the definition of the user 
    code. In that case a new user object will be instatiated for every usage.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1621"/>2.15. Transactions</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1624"/>2.15.1. Standalone transactions</h3></div></div></div><p>TODO</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1629"/>2.15.2. JTA transactions</h3></div></div></div><p>TODO</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1634"/>2.15.3. User transactions</h3></div></div></div><p>In your project you might have user domain objects 
      like e.g. an Order or Claim object in your project mapped with hibernate.
      This section explains how to combine updates to user domain objects 
      with jBPM operations in a single transaction.
      </p><p>Here's an example of a user command:</p><pre class="programlisting">public class MyUserCommand implements Command&lt;Void&gt; {
  public Void execute(Environment environment) throws Exception {
    // your user domain objects
    
    // an example jBPM operation
    ExecutionService executionService = environment.get(ExecutionService.class);
    executionService.signalExecutionById(executionId);
    
    return null;
  }
}</pre><p>Then such commands can be executed by the ProcessEngine:</p><pre class="programlisting">processEngine.execute(new MyUserCommand());</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="bpmn2"/>Chapter 3. BPMN 2.0</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#whatIsBpmn">3.1. What is BPMN 2.0?</a></span></dt><dt><span class="section"><a href="#historyAndGodl">3.2. History and goal</a></span></dt><dt><span class="section"><a href="#jpdlVsBpmn2">3.3. JPDL vs BPMN 2.0</a></span></dt><dt><span class="section"><a href="#Bpmn2Execution">3.4. Bpmn 2.0 execution</a></span></dt><dt><span class="section"><a href="#bpmn2Config">3.5. Configuration</a></span></dt><dt><span class="section"><a href="#bpmn2Examples">3.6. Examples</a></span></dt><dt><span class="section"><a href="#definitionsAndProcess">3.7. Process root element</a></span></dt><dt><span class="section"><a href="#basicConstructs">3.8. Basic constructs</a></span></dt><dd><dl><dt><span class="section"><a href="#basicConstructsEvents">3.8.1. Events</a></span></dt><dt><span class="section"><a href="#noneStartEvent">3.8.2. Event: None start event</a></span></dt><dt><span class="section"><a href="#noneEndEvent">3.8.3. Event: None end event</a></span></dt><dt><span class="section"><a href="#terminateEndEvent">3.8.4. Event: Terminate end event</a></span></dt><dt><span class="section"><a href="#sequenceFlow">3.8.5. Sequence Flow</a></span></dt><dt><span class="section"><a href="#gateway">3.8.6. Gateways</a></span></dt><dt><span class="section"><a href="#exclusiveGateway">3.8.7. Gateway: Exclusive Gateway</a></span></dt><dt><span class="section"><a href="#parallelGateway">3.8.8. Gateway: Parallel Gateway</a></span></dt><dt><span class="section"><a href="#inclusiveGateway">3.8.9. Gateway: Inclusive Gateway</a></span></dt><dt><span class="section"><a href="#task">3.8.10. Tasks</a></span></dt><dt><span class="section"><a href="#userTask">3.8.11. Task: User Task</a></span></dt><dt><span class="section"><a href="#serviceTask">3.8.12. Task: Java Service Task</a></span></dt><dt><span class="section"><a href="#scriptTask">3.8.13. Task: Script Task</a></span></dt><dt><span class="section"><a href="#manualTask">3.8.14. Task: Manual task</a></span></dt><dt><span class="section"><a href="#receiveTaskJava">3.8.15. Task: Java Receive task</a></span></dt></dl></dd><dt><span class="section"><a href="#advancedConstructs">3.9. Advanced constructs</a></span></dt><dd><dl><dt><span class="section"><a href="#embeddedSubProcess">3.9.1. Embedded sub-process</a></span></dt><dt><span class="section"><a href="#Timer start event">3.9.2. Timer start event</a></span></dt><dt><span class="section"><a href="#intermediateEvents">3.9.3. Intermediate events</a></span></dt><dt><span class="section"><a href="#intermediateCatchTimer">3.9.4. Intermediate catch event: Timer </a></span></dt></dl></dd><dt><span class="section"><a href="#completeExample">3.10. Complete example (including console task forms)</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="whatIsBpmn"/>3.1. What is BPMN 2.0?</h2></div></div></div><p>
			The Business Process Modeling Notation (BPMN) is a standard for the
			graphical notation of business process models. The standard is
			maitained by the Object Management Group (OMG).
		</p><p>	
			Basically, the BPMN specification defines how a task must look like, which constructs can
			be connected to each other, etc. in a meaning that cannot be
			misinterpreted.
		</p><p>
	    Earlier versions of the standard (&lt;= version 1.2) are limited to the modeling
			only, aiming at a common understanding between all stakeholders
			involved in documenting, discussing and implementing business
			processes. The BPMN standard has proven itself, as many modeling tools
			on the market today use the symbols and constructs specified in the
			BPMN standard. In fact, the current JPDL designer also uses BPMN
			symbols.
		</p><p>
		  Version 2.0 of the BPMN specification, which is currently in finalization phase and is
			scheduled to be finished soon, allows to add precise technical
			details to the shapes and symbols available in BPMN and at the same
			time specify what the execution semantics of BPMN 'elements' are. By
			using an XML language to specify the executable semantics of a business
			process, the BPMN specification has evolved into a language for
			business processes that can be executed on any BPMN2 compliant process
			engine - while still having the powerful graphical notation.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="historyAndGodl"/>3.2. History and goal</h2></div></div></div><p>
			The jBPM BPMN2 implementation was started in close collaboration with the
			community in augustus 2009 after releasing jBPM 4.0. 
			Later, it was decided that the first release (ie documented/QA'd) to
			incorporate parts of the BPMN2 spec would be jBPM 4.3.
		</p><p>
			The goal of this effort is to build a <span class="bold"><strong>native BPMN2 runtime engine </strong></span>
			(or better said implementing 'BPMN2 exectuable') leveraging the Process
			Virtual Machine (PVM).
			Do note that the primary focus of this release is native executability,
			not the graphical notation - but we recognize its importance for
			further releases. 
    </p><p>
      <span class="bold"><strong>
      Users who are already familiar with jBPM will find that
      <div class="itemizedlist"><ul><li>the configuration mechanism remains unchanged</li><li>the API is the same or very similar to the existing one</li><li>testing BPMN2 process still can be done with regular Java testing frameworks</li><li>the database schema remains unchanged</li></ul></div>
      </strong></span>
      So in general, our main goal is to keep everything that was good about jBPM, and enhance
      it with a standards based process language.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="jpdlVsBpmn2"/>3.3. JPDL vs BPMN 2.0</h2></div></div></div><p>
			One of the first questions that might, rightfully, come to mind is why
			BPMN2 is being implemented while there is jPDL. Both are languages
			have as goal to define executable business processes. From a high-level
			technical point of view, both languages are equivalent. The main
			distinction is that BPMN2 is as vendor-neutral as you can have with
			standards, while JPDL has always been tied to jBPM (although some might
			argue that a vendor lock-in for an open-source process language such as
			JPDL is less a lock-in than with closed-source products).
		</p><p>
			Within jBPM, both language implementations are built on top of the jBPM
			Process Virtual Machine (PVM). This means that both languages share a
			common foundation (persistence, transactions, configuration, but also
			basic process constructs, etc.). As a result, optimizations to the core
			of jBPM often benefits both languages. Leveraging the PVM, the BPMN2
			implementation is built upon a foundation that has already proven
			itself in the past and has a large end-user community.
		</p><p>
		  When evaluating the languages and comparing them which each other however,
			following points must be taken into consideration:
		  </p><div class="itemizedlist"><ul><li>BPMN2 is based on a standard accepted by the BPM industry.</li><li>BPMN2 is implementation-unaware. The downside of this is that
		      integrating with Java technology will always be easier with JPDL. So,
		      from a Java developer's perspective JPDL is simpler and feels more
		      natural (some of the 'layers' of BPEL/WSDL are in BPMN as well).</li><li>A focus of JPDL is XML readability. BPMN2 processes will still be
		      readable to a certain level, but tooling or a more detailed knowledge
		      of the spec will definitely be required to achieve the same level of
		      productivity.</li><li>Java developers who are super-fast in JPDL since they know the JPDL
		      language by heart, will find the use of tools sometimes bothersome and
		      the language itself overly complicated.</li><li>BPMN2 contains a large set of constructs described in the
		      specification. However, the "binding" of interfaces to code is left
		      open in the spec (comparable with XPDL), even if WDSL is often considered the
		      default. This means that a process portability can be lost when porting
		      the process to an engine that doesn't support the same binding
		      mechanism. Calling Java classes for example is already going to be such
		      a jBPM specific binding.</li></ul></div><p>
		</p><p>
			It is natural to the political level of BPMN2 specification process to go
			rather slow. JPDL on the other hand will be able to incorporate changes
			faster, integrate with new technologies when they are released and
			evolve generally at a quicker pace compared to BPMN2.
		
			Of course, since both are built on top of the same PVM, it is only
			logical that additions to JPDL can be ported to BPMN2 as an extension
			without much hassle.
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="Bpmn2Execution"/>3.4. Bpmn 2.0 execution</h2></div></div></div><p>
			The BPMN2 specification defines a very rich language for modeling and
			executing business processes. However, this also means that it is quite
			hard to get an overview of what's possible with BPMN2. To simplify this
			situation, we've decided to categorize the BPMN2 constructs into three
			'levels'. The separation itself is primarily based on the book 'BPMN
			method and Style' by Bruce Silver (<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.bpmnstyle.com/">http://www.bpmnstyle.com/</a>), the
			training material of Dr. Jim Arlow
			(<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slideshare.net/jimarlow/introductiontobpmn005">http://www.slideshare.net/jimarlow/introductiontobpmn005</a>), 
			'How much BPMN do you need'
			(<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.bpm-research.com/2008/03/03/how-much-bpmn-do-you-need/">http://www.bpm-research.com/2008/03/03/how-much-bpmn-do-you-need/</a>),
			and also our own experience.
		</p><p>
			We define three categories of BPMN2 constructs:
		  </p><div class="itemizedlist"><ul><li><span class="bold"><strong>Basic</strong></span>: constructs in this category are 
		      straight-forward and easy to grasp. Constructs in this category can be used to 
		      model simple business processes.</li><li><span class="bold"><strong>Advanced</strong></span>: contains more powerful or 
		      expressive constructs, but this comes with higher modeling and execution semantics 
		      learning curve. The majority of business processes are implementable with constructs from this
		      and the previous category.</li><li><span class="bold"><strong>Complex</strong></span>: constructs in this category are 
		      used in specific and/or rare cases, or their semantics are difficult to understand.</li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="bpmn2Config"/>3.5. Configuration</h2></div></div></div><p>
      Enabling BPMN 2.0 in your application is extremely simple: just add the following line
      to the <span class="bold"><strong>jbpm.cfg.xml</strong></span> file.
      </p><pre class="programlisting">
&lt;import resource="jbpm.bpmn.cfg.xml" /&gt;        
      </pre><p>
      This import will enable BPMN 2.0 process deployment by installing a BPMN 2.0 deployer
      in the Process Engine. Do note that a Process Engine can cope with both JPDL and BPMN 2.0
      processes. This means that in your application, some processes can be JPDL and others
      can be BPMN 2.0.
    </p><p>
      <span class="bold"><strong>Process definitions are distinguished by the process engine
      based on the extension of the definition file. For BPMN 2.0, use the *.bpmn.xml extension
      (where JPDL is having the *.jpdl.xml extension).</strong></span>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="bpmn2Examples"/>3.6. Examples</h2></div></div></div><p>
      The examples that are shipped with the distribution also contain examples for every 
      construct that is discussed in the following sections. Look for example BPMN 2.0
      processes and test cases in the <span class="bold"><strong>org.jbpm.examples.bpmn.* package
      </strong></span>.
    </p><p>
      See the userguide, chapter 2 (Installation), for a walktough on how to import the examples.
      Look for the section <span class="bold"><strong>'Importing the Examples'</strong></span>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="definitionsAndProcess"/>3.7. Process root element</h2></div></div></div><p>
      The root of an BPMN 2.0 XML process is the <span class="bold"><strong>definitions</strong></span> 
      elements. As the name states, the subelements will contain the actual definitions of
      the business process(es). Every <span class="bold"><strong>process</strong></span> child
      will be able to have an <span class="bold"><strong>id (required)</strong></span> and
      <span class="bold"><strong>name (optional)</strong></span>. An empty business process in BPMN 2.0
      looks as follows. Also note that it is handy to have the BPMN2.xsd on the classpath, to
      enable XML completion.
      </p><pre class="programlisting">
&lt;definitions id="myProcesses"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://schema.omg.org/spec/BPMN/2.0 BPMN20.xsd"
  xmlns="http://schema.omg.org/spec/BPMN/2.0" 
  typeLanguage="http://www.w3.org/2001/XMLSchema"
  expressionLanguage="http://www.w3.org/1999/XPath" 
  targetNamespace="http://jbpm.org/example/bpmn2"&gt;

  &lt;process id="My business processs" name="myBusinessProcess"&gt; 
  
      ...
      
  &lt;/process&gt;
&lt;definitions&gt;     
      </pre><p>
      If a name is defined for the process element, it is be used as <span class="bold"><strong>key</strong></span>
      for that process (ie. starting a process can be done by calling executionService.startProcessInstanceByKey("myBusinessProcess").
      If no name is defined, the id will be used as key. So having only an id defined, will allow
      to start a process instance using that id. So basically, name and key are of equivalent 
      in usage, for example to search process definitions. Note that for a key the same rules apply as with
      JPDL: whitespace and non alpha-numeric characters are replaced by an underscore.
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="basicConstructs"/>3.8. Basic constructs</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="basicConstructsEvents"/>3.8.1. Events</h3></div></div></div><p>
        Together with activitites and gateways, events are used in practically every business process.
        Events allow process modelers to describe business processes in a very natural way, such as
        <span class="emphasis"><em>'This process starts when I receive a customer order'</em></span>,
        <span class="emphasis"><em>'If the task is not finished in 2 days, terminate the process'</em></span>
        or <span class="emphasis"><em>'When I receive a cancel e-mail when the process is running,
        handle the e-mail using this sub-process'</em></span>. Notice that typical businesses
        always work in a very event-driven way. People are not hard-coded sequential creatures,
        but they tend to react on things that happen in their environment (ie. events).
        In the BPMN specification, a great number of event types are described, to cover the
        range of possible things that might occur in context of a business.  
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="noneStartEvent"/>3.8.2. Event: None start event</h3></div></div></div><p>
        A start event indicates the start of process (or a subprocess). Graphically, it is visualized
        as a circle with (possibly) a small icon inside. The icon specifies the actual type of event 
        that will trigger the process instance creation.
      </p><p>
        The 'none start event' is drawn as a circle without an icon inside, which means that the
        trigger is unknown or unspecified. The start activity of JPDL basically has the same
        semantics. Process instances whose process definition has a 'none start event' are 
        created using the typical API calls on the <span class="bold"><strong>executionService</strong></span>.
       </p><p>
         A none start event is defined as follows. An id is required, a name is optional.
         </p><pre class="programlisting">
&lt;startEvent id="start"  name="myStart" /&gt;            
          </pre><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="noneEndEvent"/>3.8.3. Event: None end event</h3></div></div></div><p>
			  An end event indicates the end of an execution path in a process
			  instance. Graphically,
			  it is visualized as a circle with a thick border with (possibly) a
			  small icon inside.
			  The icon specifies the type of signal that is thrown when the end is
			  reached.
      </p><p>
        The 'none end event' is drawn as a circle with thick border with no icon inside,
        which means that no signal is thrown when the execution reaches the event.
        The end activity in JPDL has the same semantics as the none end event.
      </p><p>
        A none end event is defined as follows. An id is required, a name is optional.
        </p><pre class="programlisting">
&lt;endEvent id="end" name="myEnd" /&gt;            
        </pre><p>
       </p><p>
          The following example shows a process with only a none start and end event:
          </p><div class="mediaobject" align="center"><img src="images/bpmn2.none.start.end.event.png" align="middle"/></div><p>
       </p><p>
          The corresponding executable XML for this process looks like this (omitting the 
          <span class="emphasis"><em>definitions</em></span> root element for clarity)
          </p><pre class="programlisting">
  &lt;process id="noneStartEndEvent" name="BPMN2 Example none start and end event"&gt;

    <span class="bold"><strong>&lt;startEvent id="start" /&gt;</strong></span>

    &lt;sequenceFlow id="flow1" name="fromStartToEnd"
      sourceRef="start" targetRef="end" /&gt;

    <span class="bold"><strong>&lt;endEvent id="end" name="End" /&gt;</strong></span>

  &lt;/process&gt;            
          </pre><p>
       </p><p>
          A process instances can now be created by calling the 
          <span class="bold"><strong>startProcessInstanceXXX</strong></span> operations.
          </p><pre class="programlisting">
ProcessInstance processInstance = executionService.startProcessInstanceByKey("noneStartEndEvent");
          </pre><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="terminateEndEvent"/>3.8.4. Event: Terminate end event</h3></div></div></div><p>
          The difference between a 'terminate' and a <a href="#noneEndEvent" title="3.8.3. Event: None end event">'none' end event</a> 
          lies in the fact how a path of execution is treated (or a 'token' in BPMN 2.0 terminology).
          The 'terminate' end event will end the complete process instance, whereas the 'none' 
          end event will only end the current path of execution. They both don't throw anything
          when the end event is reached.
        </p><p>
          A terminate end event is defined as follows. An id is required, a name is optional.
          </p><pre class="programlisting">
&lt;endEvent id="terminateEnd" name="myTerminateEnd"&gt;
  <span class="bold"><strong>&lt;terminateEventDefinition/&gt;</strong></span>
&lt;/endEvent&gt;            
          </pre><p>
        </p><p>
          A terminate end event is depicted as an end event (circle with thick border), 
          with a full circle as icon inside. In the following example, completing the 'task1'
          will end the process instance, while completing the 'task2' will only end the path
          of execution which enters the end event, leaving the task1 open.
          </p><div class="mediaobject" align="center"><img src="images/bpmn2.terminate.end.event.example.png" align="middle"/></div><p>
          See the examples shipped with the jBPM distribution for the unit test and XML counterpart
          of this business process.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="sequenceFlow"/>3.8.5. Sequence Flow</h3></div></div></div><p>
        A sequence flow is the connection between events, activities and gateways shown as a
        solid line with an arrow in a BPMN diagram (JPDL equivalent is the transition).
        Each sequence flow has exactly one <span class="bold"><strong>source</strong></span> and exactly one 
        <span class="bold"><strong>target</strong></span> reference, that contains the <span class="bold"><strong>id</strong></span> 
        of an activity, event or gateway.
        </p><pre class="programlisting">
&lt;sequenceFlow id="myFlow" name="My Flow" 
        sourceRef="sourceId" targetRef="targetId" /&gt;
        </pre><p>
      </p><p>
        An important difference with JPDL is the behaviour of multiple outgoing sequence flows.
        In JPDL, only one transition is selected as outgoing transition, unless the activity
        is a fork (or a custom activity with fork behaviour). However, in BPMN, the standard behaviour
        of multiple outgoing sequence flow is to split the incoming token ('execution' in jBPM
        terminology) into a collection of tokens, one for each outgoing sequence flow. In the following
        situation, after completing the first task, there will be three tasks activated instead of one.
       </p><div class="mediaobject" align="center"><img src="images/bpmn2.sequence.flow.png" align="middle"/></div><p>
       To avoid that a certain sequence flow is taken, one has to add a condition to the sequence flow.
       At runtime, only when the condition evaluates to true, that sequence flow will
       be taken.
      </p><p>
        To put a condition on a sequence flow, add a <span class="bold"><strong>conditionExpression
        </strong></span> element to the sequence flow. Conditions are to be put between <span class="bold"><strong>
        ${}</strong></span>.
        </p><pre class="programlisting">
&lt;sequenceFlow id=....&gt;
  <span class="bold"><strong>&lt;conditionExpression xsi:type="tFormalExpression"&gt;${amount &gt;= 500}&lt;/conditionExpression&gt;</strong></span>   
&lt;/sequenceFlow&gt;    
        </pre><p>
        Note that is currently is necessary to add the <span class="bold"><strong>
        xsi:type="tFormalExpression"</strong></span> to the <span class="bold"><strong>
        conditionExpression</strong></span>. A conditional sequence flow is visualized as a mini diamond
        shape at the beginning of the sequence flow. Keep in mind that conditions always can be defined 
        on sequence flow, but some constructs will not interprete them (eg. parallel gateway).
      </p><p>
        Activities (such as the user task) and gateways (such as  the exclusive gateway) can have a
        default sequence flow. This default sequence flow is taken only when all the other outgoing
        sequence flow from an activity or gateway have a condition that evaluate to false. A
        default sequence flow is graphically visualized as a sequence flow with a 'slash marker'.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.default.sequence.flow.png" align="middle"/></div><p>
        The default sequence flow is specified by filling in the <span class="bold"><strong>'default'
        attribute </strong></span> of the activity or gateway.
      </p><p>
         Also note that an expression on a default sequence flow is ignored.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gateway"/>3.8.6. Gateways</h3></div></div></div><p>
        A gateway in BPMN is used to control the flow through the process. More specifically, 
        when a token (the BPMN 2.0 conceptual notion of an execution) arrives in a gateway, it can be merged 
        or split depending on the gateway type.
      </p><p>
        Gateways are depicted as a diamond shape, with an icon inside specifying the type 
        (exclusive, inclusive, etc.).
      </p><p>
        On every gateway type, the attribute <span class="bold"><strong>gatewayDirection</strong></span>
        can be set. following values are possible:
        </p><div class="itemizedlist"><ul><li><span class="bold"><strong>unspecificed (default)</strong></span>: the gateway may have multiple
            incoming and multiple sequence flow.
          </li><li><span class="bold"><strong>mixed</strong></span>: the gateway must have multiple incoming and
            multiple outgoing sequence flow.
          </li><li><span class="bold"><strong>converging</strong></span>: the gateway must have multiple incoming
            sequence flow, but can have only one outgoing sequence flow.
          </li><li><span class="bold"><strong>diverging</strong></span>: the gateway must have only one incoming
            sequence flow and multiple outgoing sequence flow.
          </li></ul></div><p>
        Take for example the following example: a parallel gateway that has as gatewayDirection
        'converging', will have a join behaviour.
        </p><pre class="programlisting">
&lt;parallelGateway id="myJoin" name="My synchronizing join" gatewayDirection="converging" /&gt;        
        </pre><p>
        <span class="bold"><strong>Note</strong></span>: the 'gatewayDirection' attribute is optional according 
        to the specification. This means that we cannot rely on this attribute at runtime to
        know which type of behaviour a certain gateway has (for example for a parallel gateway if
        we have joining of forking behaviour). However, the 'gatewayDirection' attribute is used at parsing 
        time as a constraint check for the incoming/outgoing sequence flow. So using this 
        attribute will lower the chance on errors when referencing sequence flow, but is not
        required.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="exclusiveGateway"/>3.8.7. Gateway: Exclusive Gateway</h3></div></div></div><p>
        An exclusive gateway represents an <span class="bold"><strong>exclusive decision</strong></span>
        in the process. Exactly one outgoing sequence flow will be taken, depending on the conditions
        defined on the sequence flow.
      </p><p>
        The corresponding JPDL construct with the same semantics is the 
        <span class="bold"><strong>decision</strong></span> activity. The full technical name of the 
        exclusive gateway is the <span class="bold"><strong>'exclusive data-based gateway'</strong></span>,
        but it is also often called the <span class="bold"><strong>XOR Gateway</strong></span>.
        The XOR gateway is depicted as a diamond with a 'X' icon inside. An empty diamond
        without a gateway also signifies an exclusive gateway.
      </p><p>
        The following diagram shows the usage of an exclusive gateway: depending on the value of the
        amount variable, one of the three outgoing sequence flow out of the exclusive gateway
        is chosen.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.exclusive.gateway.png" align="middle"/></div><p>
        The corresponding executable XML of this process looks as follows.
        Note that the conditions are defined on the sequence flow. The exclusive gateway will select
        the single sequence flow for which its condition evaluates to true. If multiple conditions
        evaluate to true, the first one encountered will be taken (a log message will indicate
        this situation).
        </p><pre class="programlisting">
  &lt;process id="exclusiveGateway" name="BPMN2 Example exclusive gateway"&gt;

    &lt;startEvent id="start" /&gt;

   &lt;sequenceFlow id="flow1" name="fromStartToExclusiveGateway"
      sourceRef="start" targetRef="decideBasedOnAmountGateway" /&gt;
      
   <span class="bold"><strong>&lt;exclusiveGateway id="decideBasedOnAmountGateway" name="decideBasedOnAmount" /&gt;</strong></span>
   
   &lt;sequenceFlow id="flow2" name="fromGatewayToEndNotEnough"
      sourceRef="decideBasedOnAmountGateway" targetRef="endNotEnough"&gt;
      <span class="bold"><strong>&lt;conditionExpression xsi:type="tFormalExpression"&gt;
        ${amount &lt; 100}
      &lt;/conditionExpression&gt;</strong></span>
   &lt;/sequenceFlow&gt;
      
   &lt;sequenceFlow id="flow3" name="fromGatewayToEnEnough"
      sourceRef="decideBasedOnAmountGateway" targetRef="endEnough"&gt;
      <span class="bold"><strong>&lt;conditionExpression xsi:type="tFormalExpression"&gt;
        ${amount &lt;= 500 &amp;&amp; amount &gt;= 100}
        &lt;/conditionExpression&gt;</strong></span>
   &lt;/sequenceFlow&gt;
      
   &lt;sequenceFlow id="flow4" name="fromGatewayToMoreThanEnough"
      sourceRef="decideBasedOnAmountGateway" targetRef="endMoreThanEnough"&gt;
      <span class="bold"><strong>&lt;conditionExpression xsi:type="tFormalExpression"&gt;
        ${amount &gt; 500}
      &lt;/conditionExpression&gt;</strong></span>
   &lt;/sequenceFlow&gt;   

   &lt;endEvent id="endNotEnough" name="not enough" /&gt;
   
   &lt;endEvent id="endEnough" name="enough" /&gt;
   
   &lt;endEvent id="endMoreThanEnough" name="more than enough" /&gt;

  &lt;/process&gt;        
        </pre><p>
        This process needs a variable such that the expression can be evaluated at runtime.
        Variables can be provided when starting the process instance (similar to JPDL):
        </p><pre class="programlisting">
Map&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();
vars.put("amount", amount);
ProcessInstance processInstance = executionService.startProcessInstanceByKey("exclusiveGateway", vars);        
        </pre><p>
      </p><p>
        The exclusive gateway requires that all outgoing sequence flow have conditions defined
        on them. An exception to this rule is the default sequence flow.
        Use the <span class="bold"><strong>default attribute</strong></span> to reference an existing
        <span class="bold"><strong>id of a sequence flow</strong></span>. This sequence flow will be taken
        when the conditions on the other outgoing sequence flow all evaluate to false.
        </p><pre class="programlisting">
&lt;exclusiveGateway id="decision" name="decideBasedOnAmountAndBankType" <span class="bold"><strong>default="myFlow"</strong></span>/&gt;
   
&lt;sequenceFlow id="myFlow" name="fromGatewayToStandard"
    sourceRef="decision" targetRef="standard"&gt;
&lt;/sequenceFlow&gt;        
        </pre><p>
        An exclusive gateway can have both convering and diverging functionality. The logic is 
        easy to grasp: for every execution that arrives at the gateway, one outgoing sequence
        flow is selected to continue the flow.  The following diagram is completely legal in
        BPMN 2.0 (omitting names and conditions for clarity). 
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.exclusive.gateway.splitting.and.merging.png" align="middle"/></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="parallelGateway"/>3.8.8. Gateway: Parallel Gateway</h3></div></div></div><p>
        A parallel gateway is used to split or synchronize the respectively incoming or outgoing
        sequence flow.
        </p><div class="itemizedlist"><ul><li>
            A parallel gateway with one incoming sequence flow and more than one outgoing sequence
            flow is called a <span class="bold"><strong>'parallel split</strong></span> or an 
            <span class="bold"><strong>'AND-split'</strong></span>. All outgoing sequence flow are going to
            be taken in parallel. <span class="bold"><strong>Note: as defined by the specification,
            conditions on the outgoing sequence flow are ignored.</strong></span></li><li>
            A parallel gateway with multiple incoming sequence flow and one outgoing sequence flow
            is called a <span class="bold"><strong>'parallel join'</strong></span> or an 
            <span class="bold"><strong>AND-join</strong></span>. All incoming sequence flow need to arrive
            in this parallel joing before the outgoing sequence flow is taken.
          </li></ul></div><p>
        A parallel gateway is defined as follows:
        </p><pre class="programlisting">
&lt;parallelGateway id="myParallelGateway" name="My Parallel Gateway" /&gt;        
        </pre><p>
        Note that the 'gatewayDirection' attribute can be used to catch modeling errors at parsing 
        time (see above).
      </p><p>
        The following diagram shows how a parallel gateway can be used. After process start,
        both the 'prepare shipment' and 'bill customer' user tasks will be active.
        The parallel gateway is depicted as a diamond shape with a plus icon inside, both for the 
        splitting and joining behaviour.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.parallel.gateway.png" align="middle"/></div><p>
        The XML counterpart of this diagram looks as follows:
        </p><pre class="programlisting">
  &lt;process id="parallelGateway" name="BPMN2 example parallel gatewar"&gt;
  
    &lt;startEvent id="Start" /&gt;

    &lt;sequenceFlow id="flow1" name="fromStartToSplit"
      sourceRef="Start"
      targetRef="parallelGatewaySplit"  /&gt;

    <span class="bold"><strong>&lt;parallelGateway id="parallelGatewaySplit" name="Split" 
      gatewayDirection="diverging"/&gt;</strong></span>

    &lt;sequenceFlow id="flow2a" name="Leg 1"
      sourceRef="parallelGatewaySplit"
      targetRef="prepareShipment" /&gt;
      
    &lt;userTask id="prepareShipment" name="Prepare shipment" 
      implementation="other" /&gt;
    
    &lt;sequenceFlow id="flow2b" name="fromPrepareShipmentToJoin"
      sourceRef="prepareShipment"
      targetRef="parallelGatewayJoin"  /&gt;
      
    &lt;sequenceFlow id="flow3a" name="Leg 2" 
      sourceRef="parallelGatewaySplit"
      targetRef="billCustomer" /&gt;
      
    &lt;userTask id="billCustomer" name="Bill customer" 
      implementation="other" /&gt;
    
    &lt;sequenceFlow id="flow3b" name="fromLeg2ToJoin"
      sourceRef="billCustomer"
      targetRef="parallelGatewayJoin"  /&gt;

    <span class="bold"><strong>&lt;parallelGateway id="parallelGatewayJoin" name="Join" 
      gatewayDirection="converging"/&gt;</strong></span>
      
    &lt;sequenceFlow id="flow4" 
      sourceRef="parallelGatewayJoin"
      targetRef="End"&gt;
    &lt;/sequenceFlow&gt;

    &lt;endEvent id="End" name="End" /&gt;
    
  &lt;/process&gt;
        </pre><p>
        A parallel gateway (as is the case for any gateway) can have both splitting and 
        merging behaviour. The following diagram is completely legal BPMN 2.0. After process start,
        both task A and B will be active. When both A en B are completed, tasks C,D and E will be 
        active.                                 
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.parallel.gateway.splitting.and.merging.png" align="middle"/></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="inclusiveGateway"/>3.8.9. Gateway: Inclusive Gateway</h3></div></div></div><p>
        An inclusive gateway - also called an <span class="bold"><strong>OR-gateway</strong></span> - is used
        to 'conditionally' split or merge sequence flow. It basically behaves as a parallel 
        gateway, but it also takes in account conditions on the outgoing sequence flow (split behaviour)
        and calculates if there are executions left that could reach the gateway (merge behaviour).
      </p><p>
        The inclusive gateway is depicted as a typical gateway shape with a circle inside (referring to 'OR' semantics).
        Unlike the exclusive gateway, all condition expressions are evaluated (diverging or 'split' behaviour).
        For every expression that evaluates to true, a new child execution is created. 
        Sequence flow without a condition will always be taken (ie. a child execution will always be
        created in that case). 
     </p><p>
        A converging inclusive gateway ('merge' behaviour) has a somewhat more difficult execution logic.
        When an execution (Token in BPMN 2.0 terminology) arrives at the merging inclusive gateway, 
        the following is checked (quoting the specification literally): 
        
        </p><pre class="programlisting">
For each empty incoming sequence flow, there is no 
Token in the graph anywhere upstream of this sequence flow, i.e., there is no directed path 
(formed by Sequence Flow)  from a Token to this sequence flow unless 
a) the path visits the inclusive gateway or 
b) the path visits a node that has a directed path to a non-empty
   incoming sequence flow of the inclusive gateway. "
        </pre><p>
        
        In more simple words: when an execution arrives at the gateway, all active execution are
        checked if they can reach the inclusive gateway, by only taking in account the sequence flow
        (note: conditions are not evaluated!). When the inclusive gateway is used, it is usally
        used in a pair of splitting/merging inclusive gateways. In those cases, the execution
        behaviour is easy enough to grasph by just looking at the model. 
        
     </p><p>   
        Of course, it is not hard to imagine situations where the executions are split and merged 
        in complex combinations using a variety of constructs including the inclusive gateway.
        In those cases, it could very well be that the actual execution behaviour might not be what
        the modelers' expects. So be careful when using the inclusive gateway and keep in mind
        that it is often the best practice to use inclusive gateways just in pairs.
      </p><p>
        The following diagram shows how the inclusive gateway can be used.
        (example taken from "BPMN method and style" by Bruce Silver)
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.inclusive.gateway.png" align="middle"/></div><p>
        We can distinguish following cases:
        </p><div class="itemizedlist"><ul><li><span class="bold"><strong>Cash more than 10000 and not a foreign bank: </strong></span>Only the
             "Large deposit" task will be active.
           </li><li><span class="bold"><strong>Cash more than 10000 and a foreign bank: </strong></span> Both the 
             "Large deposit" and "Foreign deposit" task will be active.
           </li><li><span class="bold"><strong>Cash lower than 10000 and a foreign bank: </strong></span> Only the 
             "Foreign deposit" task will be active.
           </li><li><span class="bold"><strong>Cash lower than 10000 and not a foreign bank: </strong></span> In this 
             case, both expressions evaluate to false. The default sequence flow will now be chosen.
             In this example, this means that the "Standard deposit" task is active.
           </li></ul></div><p>
        No matter how many tasks are active after going through the inclusive gateway, the converging
        inclusive gateway on the right will wait until all outgoing sequence flow of the inclusive
        gateway on the left have reached the merging gateway (sometimes only one, sometimes two). Take a look at 
        <span class="bold"><strong>org.jbpm.examples.bpmn.gateway.inclusive.InclusiveGatewayTest</strong></span> 
        to see how this example reflects in a unit test.
      </p><p>
        The XML version of the example above looks as follows:
        </p><pre class="programlisting">
&lt;process id="inclusiveGateway" name="BPMN2 Example inclusive gateway"&gt;

    &lt;startEvent id="start" /&gt;

   &lt;sequenceFlow id="flow1" sourceRef="start" targetRef="inclusiveGatewaySplit" /&gt;
   
   <span class="bold"><strong>&lt;inclusiveGateway id="inclusiveGatewaySplit" default="flow3"/&gt;</strong></span>
   
   &lt;sequenceFlow id="flow2" sourceRef=<span class="bold"><strong>"inclusiveGatewaySplit"</strong></span> targetRef="largeDeposit"&gt;
      &lt;conditionExpression xsi:type="tFormalExpression"&gt;${cash &gt; 10000}&lt;/conditionExpression&gt;
   &lt;/sequenceFlow&gt;
      
   &lt;sequenceFlow id="flow3" sourceRef=<span class="bold"><strong>"inclusiveGatewaySplit"</strong></span> targetRef="standardDeposit" /&gt;
      
   &lt;sequenceFlow id="flow4" sourceRef=<span class="bold"><strong>"inclusiveGatewaySplit"</strong></span> targetRef="foreignDeposit"&gt;
      &lt;conditionExpression xsi:type="tFormalExpression"&gt;${bank == 'foreign'}&lt;/conditionExpression&gt;
   &lt;/sequenceFlow&gt;   
   
   &lt;userTask id="largeDeposit" name="Large deposit" /&gt;
   
   &lt;sequenceFlow id="flow5" sourceRef="largeDeposit" targetRef=<span class="bold"><strong>"inclusiveGatewayMerge"</strong></span> /&gt;
   
   &lt;userTask id="standardDeposit" name="Standard deposit" /&gt;
   
   &lt;sequenceFlow id="flow6" sourceRef="standardDeposit" targetRef=<span class="bold"><strong>"inclusiveGatewayMerge"</strong></span> /&gt;
   
   &lt;userTask id="foreignDeposit" name="Foreign deposit" /&gt;
   
   &lt;sequenceFlow id="flow7" sourceRef="foreignDeposit" targetRef=<span class="bold"><strong>"inclusiveGatewayMerge"</strong></span> /&gt;
   
   <span class="bold"><strong>&lt;inclusiveGateway id="inclusiveGatewayMerge" /&gt;</strong></span>
   
    &lt;sequenceFlow id="flow8" sourceRef="inclusiveGatewayMerge" targetRef="theEnd" /&gt;

   &lt;endEvent id="theEnd" /&gt;

&lt;/process&gt;
        </pre><p>
      </p><p>
        As with any gateway type, the inclusive gateway type can have both merging and splitting
        behaviour. In that case, the inclusive gateway will first wait until all executions
        have arrived, before splitting again for every sequence flow that has a condition
        that evauluates to true (or doesn't have a condition).
         </p><div class="mediaobject" align="center"><img src="images/bpmn2.inclusive.gateway.merging.and.splitting.png" align="middle"/></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="task"/>3.8.10. Tasks</h3></div></div></div><p>
        A task represents work that needs to be done by an external
        entity, such as a human actor or an automated service.
      </p><p>
        It's important to note that the BPMN semantics of a 'task' differ from the JPDL semantics.
        In JPDL, the concept 'task' is always used in the context of a human actor doing some 
        type of work. When the process engine encounters a task in JPDL, it will create a task in some human
        actor's task list and it will behave as a wait state. In BPMN 2.0 however, there are several
        task types, some indicating a wait state (eg. the <span class="bold"><strong>User Task</strong></span>
        and some indicating an automatic activity (eg. the <span class="bold"><strong>Service Task</strong></span>).
        So take good care not to confuse the meaning of the task concept when switching languages.
      </p><p>
        Tasks are depicted by a rounded rectangle, typically containing a text inside. The type
        of the task (user task, service task, script task, etc.) is shown as a little icon on the left top 
        corner of the rectangle. Depending on the task type, the engine will execute different 
        functionality.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="userTask"/>3.8.11. Task: User Task</h3></div></div></div><p>
        A <span class="bold"><strong>User task</strong></span> is the typical 'human task' that is found
        in practically every workflow or BPM software out there. When process execution reaches
        such a user task, a new human task is created in task list for a given user.
     </p><p>   
        The main difference with a <a href="#manualTask" title="3.8.14. Task: Manual task">manual task</a> (which also signifies
        work for a human actor) is that the task is known to the process engine. The engine can 
        track the completion, assignee, time, etc which is not the case for a manual task.  
      </p><p>
        A user task is depicted as a rounded rectangle with a small user icon in the top left corner.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.user.task.png" align="middle"/></div><p>
        A user task is defined as follows in the BPMN 2.0 XML:
        </p><pre class="programlisting">
&lt;userTask id="myTask" name="My task" /&gt;      
        </pre><p> 
        According to the specification, multiple implementations are possible (Webservice, WS-humantask, etc.),
        as stated by using the <span class="bold"><strong>implementation</strong></span> attribute.
        Currently, only the standard jBPM task mechanism is available, so there is no point (yet)
        in defining the 'implementation' attribute.
      </p><p>
        The BPMN 2.0 specification contains quite a few ways of assigning user tasks to user(s), 
        group(s), role(s), etc. The current BPMN 2.0 jBPM implementation allows to assign tasks using
        a <span class="bold"><strong>resourceAssignmentExpression</strong></span>, combined
        with the <span class="bold"><strong>humanPerformer or PotentialOwner</strong></span> construct.
        It is to be expected that this area will evolve future releases.
      </p><p>
        A <span class="bold"><strong>potentialOwner</strong></span> is used when you want to make a certain
        user, group, role, etc. a <span class="bold"><strong>candidate</strong></span> for a certain task.
        Take the following example. Here the candidate group for the task 'My task' will be
        the 'management' group. Also note that a resource must be defined <span class="bold"><strong>
        outside the process</strong></span>, such that the task assignment can reference the resource.
        In fact, any activity can reference one or more resource elements.
        Currently, only defining this resource is enough (since it is a required attribute by the spec),
        but this will be enhanced in a later release (eg. resources can have runtime parameters).
        </p><pre class="programlisting">
&lt;resource id="manager" name="manager" /&gt; 

&lt;process ...&gt;

...        
        
&lt;userTask id="myTask" name="My task"&gt;
  &lt;potentialOwner resourceRef="manager" jbpm:type="group"&gt;
    &lt;resourceAssignmentExpression&gt;
      &lt;formalExpression&gt;management&lt;/formalExpression&gt;
    &lt;/resourceAssignmentExpression&gt;
  &lt;/potentialOwner&gt;
&lt;/userTask&gt;        
        </pre><p>
        Note that we are using a specific extension here 
        (<span class="bold"><strong>jbpm:type="group"</strong></span>), to define this is a group assignment.
        If this attribute is removed, the group semantics will be used as default (which would be 
        ok in this example).
        Now suppose that Peter and Mary are a member of the management group (here using the default
        identity service):
        </p><pre class="programlisting">
identityService.createGroup("management");
    
identityService.createUser("peter", "Peter", "Pan");
<span class="bold"><strong>identityService.createMembership("peter", "management");</strong></span>
    
identityService.createUser("mary", "Mary", "Littlelamb");
<span class="bold"><strong>identityService.createMembership("mary", "management");  </strong></span>      
        </pre><p>
        Then both peter and mary can look in their task list for this task (code snippet from the 
        example unit test):
        </p><pre class="programlisting">
// Peter and Mary are both part of management, so they both should see the task
List&lt;Task&gt; tasks = taskService.findGroupTasks("peter");
assertEquals(1, tasks.size());
<span class="bold"><strong> tasks = taskService.findGroupTasks("mary");</strong></span>
assertEquals(1, tasks.size());
    
// Mary claims the task
Task task = tasks.get(0);
taskService.takeTask(task.getId(), "mary");
assertNull(taskService.createTaskQuery().candidate("peter").uniqueResult());
    
taskService.completeTask(task.getId());
assertProcessInstanceEnded(processInstance);        
        </pre><p>
        When the assignment should be done to a <span class="bold"><strong>candidate user</strong></span>,
        just use the <span class="bold"><strong>jbpm:type="user"</strong></span> attribute.
        </p><pre class="programlisting">
&lt;userTask id="myTask" name="My User task"&gt;
  &lt;potentialOwner resourceRef="employee" <span class="bold"><strong>jbpm:type="user"</strong></span>&gt;
    &lt;resourceAssignmentExpression&gt;
      &lt;formalExpression&gt;peter&lt;/formalExpression&gt;
    &lt;/resourceAssignmentExpression&gt;
  &lt;/potentialOwner&gt;
&lt;/userTask&gt;        
        </pre><p>
        In this example, peter will be able to find the task since he's a candidate user for the task.
        </p><pre class="programlisting">
List&lt;Task&gt; tasks = taskService.createTaskQuery().candidate("peter").list();        
        </pre><p>
      </p></div><p>
      A <span class="bold"><strong>human performer</strong></span> is used when you want to assign a task
      directly to a certain user, group, role, etc. The way to do this looks very much
      like that of the potential owner.
      </p><pre class="programlisting">
&lt;resource id="employee" name="employee" /&gt;      

&lt;process ...&gt;

...        
         
&lt;userTask id="myTask" name="My User task"&gt;
  <span class="bold"><strong>&lt;humanPerformer resourceRef="employee"&gt;</strong></span>
    &lt;resourceAssignmentExpression&gt;
      &lt;formalExpression&gt;mary&lt;/formalExpression&gt;
    &lt;/resourceAssignmentExpression&gt;
  &lt;/humanPerformer&gt;
&lt;/userTask&gt;      
      </pre><p>
      In this example, the task will be directly assigned to Mary. She can now find the task
      in her task list:
      </p><pre class="programlisting">
List&lt;Task&gt; tasks = taskService.findPersonalTasks("mary");       
      </pre><p>
      
      
    </p><p>
      Since the task assignment is done through the use of a 
      <span class="bold"><strong>formalExpression</strong></span>, it's also possible to define expressions
      that are evaluated at runtime. The expressions itself need to be put inside a 
      <span class="bold"><strong>${}</strong></span>, as usual in jBPM.
      For example, if a process variable 'user' is defined, then  it can be used inside an expression.
      More complex expressions are of course possible.
      </p><pre class="programlisting">
&lt;userTask id="myTask" name="My User task"&gt;
  &lt;humanPerformer resourceRef="employee"&gt;
    &lt;resourceAssignmentExpression&gt;
      <span class="bold"><strong>&lt;formalExpression&gt;${user}&lt;/formalExpression&gt;</strong></span>
    &lt;/resourceAssignmentExpression&gt;
  &lt;/humanPerformer&gt;
&lt;/userTask&gt;         
      </pre><p>
      Note that it is not needed to use the 'jbpm:type' on a humanPerformer element, since only
      direct user assignments can be done. If a task needs to be assigned to a role or group, 
      use the potentialOwner with a group type (when you assign a task to a group, all members
      of that group will always be candidate users for that group - hence the usage of 
      potentialOwner).
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="serviceTask"/>3.8.12. Task: Java Service Task</h3></div></div></div><p>
        A <span class="bold"><strong>Service Task</strong></span> is an automatic activity that calls some 
        sort of service, such as a web service, Java service, etc. Currently, only Java service
        invocations are supported by the jBPM engine, but Web service invocations are planned 
        for a future release.
          </p><div class="mediaobject" align="center"><img src="images/bpmn2.service.task.png" align="middle"/></div><p>
      </p><p>
        Defining a service task requires quite a few lines of XML (the BPEL influence is certainly
        visible here). Of course, in the near future, we expect that tooling will simplify this area
        a lot. A service task is defined as follows:
        </p><pre class="programlisting">
&lt;serviceTask id="MyServiceTask" name="My service task" 
  implementation="Other" operationRef="myOperation" /&gt;
        </pre><p>
        The service task has a required <span class="bold"><strong>id</strong></span> and an optional
        <span class="bold"><strong>name</strong></span>. The <span class="bold"><strong>implementation</strong></span>
        attribute is used to indicate what the type of the invoked service is. Possible values
        are WebService, Other or Unspecified. Since we've only implemented the Java invocation,
        only the <span class="bold"><strong>Other</strong></span> choice will do something useful for the moment.
      </p><p>
        The service task will invoke a certain operation that is referenced by the 
        <span class="bold"><strong>operationRef</strong></span> attribute using the id of an 
        <span class="bold"><strong>operation</strong></span>. Such an operation is part of an 
        <span class="bold"><strong>interface</strong></span> as shown below. Every operation has 
        at least one <span class="bold"><strong>input message</strong></span> and at most one
        <span class="bold"><strong>output message</strong></span>.
        </p><pre class="programlisting">
&lt;interface id="myInterface"
    name="org.jbpm.MyJavaServicek"&gt;
    &lt;operation id="myOperation2" name="myMethod"&gt;
      &lt;inMessageRef&gt;inputMessage&lt;/inMessageRef&gt;
      &lt;outMessageRef&gt;outputMessage&lt;/outMessageRef&gt;
    &lt;/bpmn:operation&gt;
&lt;/interface&gt;        
        </pre><p>
        For a Java service, the <span class="bold"><strong>name of the interface</strong></span> is used
        to specificy the fully qualified classname of the Java class. The <span class="bold"><strong>
        name of the operation</strong></span> is then used to specify the name of the method
        that must be called. The input/output message that represent the parameters/return value of
        the Java method are defined as follows:
        </p><pre class="programlisting">
&lt;message id="inputMessage" name="input message" structureRef="myItemDefinition1" /&gt;        
        </pre><p>
        Several elements in BPMN are so-called 'item-aware', including this message construct.
        This means that they are involved in storing or reading items during process execution.
        The data structure to hold these elements is specified using a reference to an 
        <span class="bold"><strong>ItemDefinition</strong></span>. In this context, the message specifies 
        its data structure by referencing an Itemdefinition in the 
        <span class="bold"><strong>structureRef</strong></span> attribute.
        </p><pre class="programlisting">
        
  &lt;itemDefinition id="myItemDefinition1" &gt;
    &lt;jbpm:arg&gt;
      &lt;jbpm:object expr="#{var1}" /&gt;
    &lt;/jbpm:arg&gt;
  &lt;/itemDefinition&gt;
  
  &lt;itemDefinition id="myItemDefinition2"&gt;
    &lt;jbpm:var name="returnVar" /&gt;
  &lt;/itemDefinition&gt;
          
        </pre><p>
        Do note that this is not fully standard BPMN 2.0 as by the specification (hence the 'jbpm' prefix).
        In fact, according to the specification, the ItemDefinition shouldn't contain more
        than a data structure definition. The actual mapping between input paramaters, with a ceratin
        data structure, is done in the <span class="bold"><strong>ioSpecification</strong></span> section
        of the serviceTask. However, the current jBPM BPMN 2.0 implementation hasn't implemented
        that construct yet. So, this means that the current usage as described above, will probably 
        change in the near future.
      </p><p>
        <span class="bold"><strong>Important note: Interfaces, ItemDefinitions and messages are
        defined outside a &lt;process&gt;.</strong></span> See the example <span class="bold"><strong>
        ServiceTaskTest</strong></span> for a concrete process and unit test.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="scriptTask"/>3.8.13. Task: Script Task</h3></div></div></div><p>
        A script task is a an automatic activity upon which the process engine will execute 
        a script when the task is reached. The script task is used as follows:
        </p><pre class="programlisting">
&lt;scriptTask id="scriptTask" name="Script Task" scriptLanguage="bsh"&gt;
  &lt;script&gt;&lt;![CDATA[
    for(int i=0; i &lt; input.length; i++){
      System.out.println(input[i] + " x 2 = " + (input[i]*2));
    }]]&gt;
  &lt;/script&gt;
&lt;/scriptTask&gt;       
        </pre><p>
        The script task, besides the required <span class="bold"><strong>id</strong></span> and the optional
        <span class="bold"><strong>name</strong></span>, allows for specifying a <span class="bold"><strong>
        scriptLanguage</strong></span> and a <span class="bold"><strong>script</strong></span>. 
        Since we're using JSR-223 ('Scripting for the Java platform'), changing the script language involves
        </p><div class="itemizedlist"><ul><li>changing the <span class="bold"><strong>scriptLanguage</strong></span> attribute to the JSR-223 compliant name</li><li>adding the ScriptEngine implementation of the JSR specification to the classpath</li></ul></div><p>
        The XML above is visualized as follows (adding a none start and end event).
      </p><div class="mediaobject" align="center"><img src="images/bpmn2.script.task.png" align="middle"/></div><p>
        As shown in the example, process variables can be used inside the scripts. We can now start
        a process instance for this example process, while also supplying some random input variables:
        </p><pre class="programlisting">
Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
Integer[] values = { 11, 23, 56, 980, 67543, 8762524 };
variables.put("input", values);   
executionService.startProcessInstanceBykey("scriptTaskExample", variables);     
        </pre><p>
        In the output console, we can now see the script being executed:
        </p><pre class="programlisting">
11 x 2 = 22
23 x 2 = 46
56 x 2 = 112
980 x 2 = 1960
67543 x 2 = 135086
8762524 x 2 = 17525048        
        </pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="manualTask"/>3.8.14. Task: Manual task</h3></div></div></div><p>
         </p><div class="mediaobject" align="center"><img src="images/bpmn2.manual.task.png" align="middle"/></div><p>
         A manual task is a task that is performed by an external actor, but without the aid of 
         a BPM system or a service that is invoked. In the real world, examples are plenty:
         the installation of telephone system, sending of a letter using regular mail, calling 
         a customer by phone, etc.
         </p><pre class="programlisting">
&lt;manualTask id="myManualTask" name="Call customer" /&gt;         
         </pre><p>
      </p><p>
        The purpose of the manual task is more documentation/modeling-wise, as it has no meaning for
        execution on a process engine. As such, the process engine will simply pass through
        a manual task when it encounters one.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="receiveTaskJava"/>3.8.15. Task: Java Receive task</h3></div></div></div><p>
        A <span class="bold"><strong>receive task</strong></span> is a task that waits for the arrival of 
        an external message. Besides the obvious use case involving webservices, the specification
        is liberal in what to do in other environments. The web service use case is not yet 
        implemented, but the receive task can already be used in a Java environment.
      </p><p>
        The receive task is depicted as a rounded rectangle (= task shape) with a little enveloppe
        in the left top corner.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.receive.task.java.png" align="middle"/></div><p>
      </p><p>
        In a Java environment, the receive task without any other attribute filled in besides
        an id and (optionally) a name, behaves as a wait state. To introduce a wait state in your
        business process, just add the following line:
        </p><pre class="programlisting">
&lt;receiveTask id="receiveTask" name="wait" /&gt;        
        </pre><p>
        Process execution will wait in such a receive task. The process can then be continued
        using the familiar jBPM <span class="bold"><strong>signal methods</strong></span>. Note that
        this will probably change in the future, since a 'signal' has a completely different
        meaning in BPMN 2.0.
        </p><pre class="programlisting">
Execution execution = processInstance.findActiveExecutionIn("receiveTask");
executionService.signalExecutionById(execution.getId());        
        </pre><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="advancedConstructs"/>3.9. Advanced constructs</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="embeddedSubProcess"/>3.9.1. Embedded sub-process</h3></div></div></div><p>
        Subprocesses are in the first place a way of making a process "hierarchical", meaning that 
        a modeller can create several 'levels' of detail. The top level view then explains the 
        high-level way of doing things, while the lowest level focusses on the nitty gritty 
        details.
      </p><p>
        Take for example the following diagram. In this model, only the high level steps are shown.
        The actual implementation of the "Check credit" step is hidden behind a
        <span class="bold"><strong>collapsed subprocess</strong></span>, which may be the perfect level
        of detail to discuss business processes with end-users.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.collapsed.subprocess.png" align="middle"/></div><p>
      </p><p>
        The second major use case for sub-processes is that the sub-process "container"
        acts as a scope for events. When an event is fired from within the sub-process, the catch 
        events on the boundary of the sub-process will be the first to receive this event.
      </p><p>
        A sub-process that is defined within a top-level process is called an <span class="bold"><strong>
        embeddable sub-process</strong></span>. All process data that is available in the parent
        process is also available in the sub-process. The following diagram shows the expanded
        version of the model above.
         </p><div class="mediaobject" align="center"><img src="images/bpmn2.embedded.subprocess.png" align="middle"/></div><p>
         The XML counterpart of this model looks as follows:$
         </p><pre class="programlisting">
&lt;process id="embeddedSubprocess"&gt;

    &lt;startEvent id="theStart" /&gt;
    &lt;sequenceFlow id="flow1" sourceRef="theStart" targetRef="receiveOrder" /&gt;
    &lt;receiveTask name="Receive order" id="receiveOrder" /&gt;
    &lt;sequenceFlow id="flow2" sourceRef="receiveOrder" targetRef="checkCreditSubProcess" /&gt;
    <span class="bold"><strong>&lt;subProcess id="checkCreditSubProcess" name="Credit check"&gt;</strong></span>
    
      ...

    <span class="bold"><strong>&lt;/subProcess&gt;</strong></span>
    
    &lt;sequenceFlow id="flow9" sourceRef="checkCreditSubProcess" targetRef="theEnd" /&gt;
    &lt;endEvent id="theEnd" /&gt;

&lt;/process&gt;
         </pre><p>
         Note that inside the sub-process, events, activities, tasks are defined as if it were
         a top-level process (hence the three "..." within the XML example above. Sub-processes
         are <span class="bold"><strong>only allowed to have a none start event</strong></span>.
      </p><p>
        Conceptually an embedded sub-process works as follows: when an execution arrives
        at the subprocess, a child execution is created. The child execution can then later create
        other (sub-)child executions, for example when a parallel gateway is used whithin the
        sub-process. The sub-process however, is only completed when no executions are active anymore
        within the subprocess. In that case, the parent execution is taken for further continuation
        of the process.
      </p><p>   
        For example, in the following diagram, the "Third task"
        will only be reached after both the "First task" and the "Second task"
        are completed. Completing one of the tasks in the sub-process, will not trigger the
        continuation of the sub-process, since one execution is still active within the sub-process.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.subprocess.two.endevents.png" align="middle"/></div><p>
      </p><p>
        Sub-processes can have multiple start events. In that case, multiple parallel paths
        will exist within the sub-process. The rules for sub-process completion are unchanged:
        the sub-process will only be left when all the executions of the parallel paths are
        ended.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.subprocess.parallel.paths.png" align="middle"/></div><p>
      </p><p>
        Nested sub-processes are also possible. This way, the process can be divided into several
        levels of detail. There is no limitation on the levels of nesting.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.subprocess.nested.png" align="middle"/></div><p>
      </p><p>
        Implementation note: According to the BPMN 2 specification, an activity without ougoing sequence
        flow implicitly ends the current execution. However currently, it is necessary for a correct functioning to  
        specifically use an end event within the sub-process to end a certain path. This will
        be enhanced in the future to be specification-compliant.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="Timer start event"/>3.9.2. Timer start event</h3></div></div></div><p>
        A timer start event is used to indicate that a process should be started when a given
        time condition is met. This could be a specific point in time (eg. October 10th, 2010 at
        5am), but also and more typically a recurring time (eg. every Friday at midnight).  
      </p><p>
        A timer start event is visualized as a circle with the clock icon inside.
       </p><div class="mediaobject" align="center"><img src="images/bpmn2.timer.start.event.png" align="middle"/></div><p>
      </p><p>
        Using a Timer Start event is done by adding a <span class="bold"><strong>timerEventDefinition</strong></span>
        element below the startEvent element:
        </p><pre class="programlisting">
&lt;startEvent name="Every Monday morning" id="myStart"&gt;
  <span class="bold"><strong>&lt;timerEventDefinition/&gt;</strong></span>
&lt;/startEvent&gt;        
        </pre><p>
        Following time definitions are possible:
        </p><div class="itemizedlist"><ul><li><span class="bold"><strong>timeDate: </strong></span>specifies a fixed date when a process instance
            must be created. The default format of the date specification is
            "dd/MM/yyyy hh:mm:ss". This can engine-wide be changed by setting the 
            <span class="bold"><strong>jbpm.duedatetime.format</strong></span> property in the configuration.
            <pre class="programlisting">
&lt;startEvent id="myStartEvent" &gt;
  &lt;timerEventDefinition&gt;
    <span class="bold"><strong>&lt;timeDate&gt;10/10/2099 00:00:00&lt;/timeDate&gt;</strong></span>
  &lt;/timerEventDefinition&gt;
&lt;/startEvent&gt;           
            </pre>
            Note that using a fixed duedate makes the process only useable for a single time.
            After the process instance is created, the timer start event will never fire again.
          </li><li><span class="bold"><strong>timeCycle: </strong></span>specifies the recurring time when a new
            process instance will be created. Two types are possible

            <p>
                <span class="bold"><strong>Duration expression: </strong></span> 
                </p><pre class="programlisting">
quantity [business] {second | seconds | minute | minutes | 
                     hour | hours | day | days | week | 
                     weeks | month | months | year | years}                
                </pre><p>
                 This is completely similar to a timer duration definition in JPDL. Note that the 
                 BPMN2 start timer event also understands "business time". This
                 allows for example to define a "business day" as an interval from
                 9am to 5pm. This way, the time from 5pm to 9am will not be taken in account when
                 the time on which the event will fire is calculated. 
                 Please refer to the JPDL userguide for more details on how this business calendar can be customized.
                 The following example shows a timer start event that will start a new process
                 instance every five hours.
                 </p><pre class="programlisting">
&lt;startEvent id="myStartEvent" &gt;
  &lt;timerEventDefinition&gt;
    <span class="bold"><strong>&lt;timeCycle&gt;5 hours&lt;/timeCycle&gt;</strong></span>
  &lt;/timerEventDefinition&gt;
&lt;/startEvent&gt;               
                 </pre><p>
              </p><p>
                <span class="bold"><strong><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/CRON_expression">Cron expression:</a></strong></span>
                altough duration expressions cover already a great deal of recurring time definitions, 
                sometimes they are not easy to use. 
                When for example a process instance should be started every Friday night 23pm,
                cron expressions allow a more natural way of defining such repeating occurrences.
              </p><p>
                The following example shows a timer start event that will start a new process
                instance every Friday at 23pm. 
                </p><pre class="programlisting">
&lt;startEvent id="myStartEvent" &gt;
  &lt;timerEventDefinition&gt;
    <span class="bold"><strong>&lt;timeCycle&gt;0 0 23 ? * FRI&lt;/timeCycle&gt;</strong></span>
&lt;/timerEventDefinition&gt;
&lt;/startEvent&gt;               
                </pre><p>
              </p></li></ul></div><p>
      </p><p>
        The timer start event implementation in jBPM also has following features:
        </p><div class="itemizedlist"><ul><li>
            Process definitions that have a timer start event, can be started as if it also
            were a none start event. This means that calling for example 
            executionService.startProcessInstanceByKey(key) just works.
          </li><li>
            The timer start event is internally implemented as a scheduled job. This means
            that a <span class="bold"><strong>job executor</strong></span> has to be configured for
            the timer start event to work. The advantage of this implementation is that the
            timer start event firing is transactional (eg. if a service tasks right after the 
            timer start event fails, the transaction will be rolled back and the timer start event
            will be retried later) and able to cope with a server crash (ie. the when the server
            comes back up, the timer start event will be picked up by the job executor just as if
            nothing has happened).
          </li><li>
            When a new version of a process definition with a timer start event is deployed, the
            old timer start event job is removed from the system. This means that 
            <span class="bold"><strong>only the latest version of the process definition will be used</strong></span>
            to create a new process instances.
          </li></ul></div><p>        
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="intermediateEvents"/>3.9.3. Intermediate events</h3></div></div></div><p>
        An intermediate event is used to model something that happens during a process (ie. after
        the process has started and before it is ended). Intermediate events are visualized as
        a circle with a double border, with an icon indicating the event type within the circle.
      </p><p>
        There are several intermediate event types, such as a timer event, signal event, escalation
        event, etc. Intermediate events can be either throwing or catching:
        </p><div class="itemizedlist"><ul><li><span class="bold"><strong>Throwing: </strong></span>when an execution arrives in the event, it 
            immediately fires a certain trigger (a signal, an error, etc.). Throwing events can
            be graphically recognized by the icon that is filled in with black.
          </li><li><span class="bold"><strong>Catching: </strong></span>when an execution arrives in the event,
            it will wait for a certain trigger to happen (an error, a timer, etc.). Catching events
            can be graphically recognized by the icon that is not filled with black (ie. white inside).
          </li></ul></div><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="intermediateCatchTimer"/>3.9.4. Intermediate catch event: Timer </h3></div></div></div><p>
        An intermediate timer event is used to represent a <span class="bold"><strong>delay</strong></span>
        in the process. Straightfoward use cases are for example polling of data, executing
        heavy logic only at night when nobody is working, etc.
      </p><p>
        Note that an intermediate timer only can be used as a catch event (throwing a timer event
        makes no sense). The following diagram shows how the intermediate timer event is visualized.
        </p><div class="mediaobject" align="center"><img src="images/bpmn2.intermediate.timer.png" align="middle"/></div><p>
        Defining an intermediate timer event is done in XML as follows:
        </p><pre class="programlisting">
&lt;intermediateCatchEvent id="myTimer" name="Wait for an hour"&gt;
  &lt;timerEventDefinition&gt;
    &lt;timeCycle&gt;1 hour&lt;/timeCycle&gt;
  &lt;/timerEventDefinition&gt;
&lt;/intermediateCatchEvent&gt;        
        </pre><p>
        There are two ways to specify the delay, using either a <span class="bold"><strong>timeCycle
        or a timeDate</strong></span>. In the example above, a timeCycle is used.
      </p><p>
        Following delay definitions are possible (similar to those for a Timer Start Event).
        </p><div class="itemizedlist"><ul><li><span class="bold"><strong>timeDate: </strong></span>specifies a fixed date when the timer will
            fire and the process continues. The default format of the date specification is
            "dd/MM/yyyy hh:mm:ss". This can engine-wide be changed by setting the 
            <span class="bold"><strong>jbpm.duedatetime.format</strong></span> property in the configuration.
            <pre class="programlisting">
&lt;intermediateCatchEvent id="myTimer" &gt;
  &lt;timerEventDefinition&gt;
    <span class="bold"><strong>&lt;timeDate&gt;10/10/2099 00:00:00&lt;/timeDate&gt;</strong></span>
  &lt;/timerEventDefinition&gt;
&lt;/intermediateCatchEvent&gt;           
            </pre></li><li><span class="bold"><strong>timeCycle: </strong></span>specifies a delay duration relative to the
            time when the execution enters the timer event. Two types are possible

            <p>
                <span class="bold"><strong>Duration expression: </strong></span> 
                </p><pre class="programlisting">
quantity [business] {second | seconds | minute | minutes | 
                     hour | hours | day | days | week | 
                     weeks | month | months | year | years}                
                </pre><p>
                 This is completely similar to a timer duration definition in JPDL. Note that the 
                 BPMN2 intermediate timer event also understands "business time". This
                 allows for example to define a "business day" as an interval from
                 9am to 5pm. Timers that are started at 4pm with a duration of 2 hours, will fire
                 at 10am the next business day. Please refer to the JPDL userguide for more details
                 on how this business calendar can be customized.
                 </p><pre class="programlisting">
&lt;intermediateCatchEvent id="intermediateTimer" &gt;
  &lt;timerEventDefinition&gt;
    <span class="bold"><strong>&lt;timeCycle&gt;5 hours&lt;/timeCycle&gt;</strong></span>
  &lt;/timerEventDefinition&gt;
&lt;/intermediateCatchEvent&gt;               
                 </pre><p>
              </p><p>
	              <span class="bold"><strong>Cron expression: </strong></span>altough duration expressions cover
	              already a great deal of delay definitions, sometimes they are not easy to use. When
	              for example the process should be delayed until Friday night 23pm such that the
	              processes can be executed in the weekend, duration expressions are hard to use
	              (you need something like "#{calculated_value} seconds", where you need
	              to calculate the value first).
	            </p><p>
	             <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/CRON_expression">Cron expressions</a>
	             allow to define delays in a way many people know (since cron expressions
	             are used to define scheduled task on Unix machines). Note that a cron expression
	             typically is used to define repetion. In this context however, the 
	             <span class="bold"><strong>first point in time where the cron expression is satisfied</strong></span>
	             is used to set the due date of the timer event (so no repetition). The following example
	             shows how an intermediate timer event can be specified to continue the process
	             the next friday night at 23pm.
	             </p><pre class="programlisting">
&lt;intermediateCatchEvent id="intermediateTimer" &gt;
  &lt;timerEventDefinition&gt;
    <span class="bold"><strong>&lt;timeCycle&gt;0 0 23 ? * FRI&lt;/timeCycle&gt;</strong></span>
      &lt;/timerEventDefinition&gt;
&lt;/intermediateCatchEvent&gt;               
	             </pre><p>
	            </p></li></ul></div><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="completeExample"/>3.10. Complete example (including console task forms)</h2></div></div></div><p>
      <span class="bold"><strong>Prerequisites</strong></span>: to run the example, we assume that a working
      jBPM console has been installed on your JBoss server. If not, please run the 'demo.setup.jboss' 
      install script first.
    </p><p>
      The business process we're implementing looks as follows:
      </p><div class="mediaobject" align="center"><img src="images/bpmn2.vacationrequest.example.png" align="middle"/></div><p>
			You might recognize this example, since we’ve also implemented it in
			JPDL as an example in our distribution.
		</p><p>
			The business process is simple: an employee can start a new process and
			make a request for a certain amount of vacation days. After the request
			task has been completed, the manager will find a verification task in
			its tasklist. The Manager can now decide to accept or reject this
			request. Depending on the outcome (that’s the little rhombus on the
			outgoing sequence flow - it means there is a conditional expression on the sequence flow),
			a rejection message is send or the process ends. Do note that in fact we've used a shortcut
			here: instead of putting expressions on the outgoing sequence flow of the 'verify request'
			task, we've could have used an exclusive gateway after the user task to control the flow
			through the process. Also note that since we haven't implemented swimlanes yet (probably
			the next release), it's difficult to actually see who does what in the business process.
    </p><p>
      The XML version of this process looks as follows:
      </p><pre class="programlisting">
&lt;process id="vacationRequestProcess" name="BPMN2 Example process using task forms"&gt;

    &lt;startEvent id="start" /&gt;

    &lt;sequenceFlow id="flow1" name="fromStartToRequestVacation"
      sourceRef="start" targetRef="requestVacation" /&gt;

    &lt;userTask id="requestVacation" name="Request Vacation"
      implementation="other"&gt;
     &lt;potentialOwner resourceRef="user" jbpm:type="group"&gt;
        &lt;resourceAssignmentExpression&gt;
          &lt;formalExpression&gt;user&lt;/formalExpression&gt;
        &lt;/resourceAssignmentExpression&gt;
      &lt;/potentialOwner&gt;
      &lt;rendering id="requestForm"&gt;
        &lt;jbpm:form&gt;org/jbpm/examples/bpmn/usertask/taskform/request_vacation.ftl&lt;/jbpm:form&gt;
      &lt;/rendering&gt;
    &lt;/userTask&gt;

    &lt;sequenceFlow id="flow2"
      name="fromRequestVacationToVerifyRequest" sourceRef="requestVacation"
      targetRef="verifyRequest" /&gt;

    &lt;userTask id="verifyRequest" name="Verify Request"
      implementation="other"&gt;
      &lt;potentialOwner resourceRef="user" jbpm:type="group"&gt;
        &lt;resourceAssignmentExpression&gt;
          &lt;formalExpression&gt;manager&lt;/formalExpression&gt;
        &lt;/resourceAssignmentExpression&gt;
      &lt;/potentialOwner&gt;
      &lt;rendering id="verifyForm"&gt;
        &lt;jbpm:form&gt;org/jbpm/examples/bpmn/usertask/taskform/verify_request.ftl&lt;/jbpm:form&gt;
      &lt;/rendering&gt;
    &lt;/userTask&gt;

    &lt;sequenceFlow id="flow3" name="fromVerifyRequestToEnd"
      sourceRef="verifyRequest" targetRef="theEnd"&gt;
      &lt;conditionExpression xsi:type="tFormalExpression"&gt;
        ${verificationResult == 'OK'}
      &lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;

    &lt;sequenceFlow id="flow4"
      name="fromVerifyRequestToSendRejectionMessage" sourceRef="verifyRequest"
      targetRef="sendRejectionMessage"&gt;
      &lt;conditionExpression xsi:type="tFormalExpression"&gt;
        ${verificationResult == 'Not OK'}
      &lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;

    &lt;scriptTask id="sendRejectionMessage" name="Send rejection Message"
      scriptLanguage="bsh"&gt;
      &lt;script&gt;
        &lt;![CDATA[System.out.println("Vacation request refused!");]]&gt;
      &lt;/script&gt;
    &lt;/scriptTask&gt;

    &lt;sequenceFlow id="flow5"
      name="fromSendRejectionMessageToEnd" sourceRef="sendRejectionMessage"
      targetRef="theEnd" /&gt;

    &lt;endEvent id="theEnd" name="End" /&gt;
&lt;/process&gt;          
      </pre><p>
      <span class="bold"><strong>Note</strong></span>: this example is already installed when you've 
      used the demo setup. Also note that we're using a Script Task here, to quickly write
      something as output instead of sending a real message (the diagram is showing a Service
      Task). Also note that we've taken some shortcuts here regarding task assignment (will
      be fixed in the next release).
    </p><p>
      The constructs used in this implementation are all covered in the previous section.
      Also note that we're using the <span class="bold"><strong>taskform functionality</strong></span> 
      here, which is a custom jBPM extension for the <span class="bold"><strong>rendering</strong></span>
      element of a User task.
      </p><pre class="programlisting">
&lt;userTask id="verifyRequest" name="Verify Request"
       implementation="other"&gt;
  &lt;potentialOwner resourceRef="user" jbpm:type="group"&gt;
    &lt;resourceAssignmentExpression&gt;
      &lt;formalExpression&gt;user&lt;/formalExpression&gt;
    &lt;/resourceAssignmentExpression&gt;
  &lt;/potentialOwner&gt;
  &lt;rendering id="verifyForm"&gt;
    &lt;jbpm:form&gt;org/jbpm/examples/bpmn/usertask/taskform/verify_request.ftl&lt;/jbpm:form&gt;
  &lt;/rendering&gt;
&lt;/userTask&gt;
      </pre><p>  
      The mechanism regarding task forms for BPMN 2.0 is complete equivalent to that of JPDL.
      The form itself is a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://freemarker.org/">Freemarker</a> template file
      that needs to be incorporated in the deployment. For example, the 'verify_request.ftl' form
      looks like as follows.
      </p><pre class="programlisting">
&lt;html&gt;
  &lt;body&gt;

    &lt;form action="${form.action}" method="POST" enctype="multipart/form-data"&gt;
    
      &lt;h3&gt;Your employee, <span class="bold"><strong>${employee_name}</strong></span> would like to go on vacation&lt;/h3&gt;
      Number of days: <span class="bold"><strong>${number_of_days}&lt;</strong></span>br/&gt;
      
      &lt;hr&gt;
      
      In case you reject, please provide a reason:&lt;br/&gt;
      <span class="bold"><strong>&lt;input type="textarea" name="reason"/&gt;&lt;br/&gt;</strong></span>
     
      <span class="bold"><strong>&lt;input type="submit" name="verificationResult" value="OK"&gt;
      &lt;input type="submit" name="verificationResult" value="Not OK"&gt;</strong></span>
      
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;      
      </pre><p>
      Note that <span class="bold"><strong>process variables can be 
      accessed using the ${my_process_variable} construct.</strong></span> Also note that named
      input controls (eg. input field, submit button) can be used to 
      <span class="bold"><strong>define new process variables</strong></span>. 
      For example, the text input of the following field will be stored as the process
      variable 'reason'
      </p><pre class="programlisting">
&lt;input type="textarea" name="reason"/&gt;     
      </pre><p>
      Note that there are two submit buttons (which makes sense if you look at the 'OK' and 'Not OK'
      sequence flows going out the 'request vacation' task. By pressing one of these buttons, the
      process variable 'verificationResult' will be stored. It can then be used to evaluate the
      outgoing sequence flow:
      </p><pre class="programlisting">
&lt;sequenceFlow id="flow3" name="fromVerifyRequestToEnd"
      sourceRef="verifyRequest" targetRef="theEnd"&gt;
  &lt;conditionExpression xsi:type="tFormalExpression"&gt;
    <span class="bold"><strong>${verificationResult == 'OK'}</strong></span>
  &lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;      
      </pre><p>
    </p><p>
      The process can now be deployed. You can use the ant deploy task for this (see examples),
      or you can point your jBPM configuration to the database of the console. To deploy
      your process programmatically, you need to add the task forms to your deployment:
      </p><pre class="programlisting">
NewDeployment deployment = repositoryService.createDeployment();
deployment.addResourceFromClasspath("org/jbpm/examples/bpmn/usertask/taskform/vacationrequest.bpmn.xml");
deployment.addResourceFromClasspath("org/jbpm/examples/bpmn/usertask/taskform/request_vacation.ftl");
deployment.addResourceFromClasspath("org/jbpm/examples/bpmn/usertask/taskform/verify_request.ftl");
deployment.deploy();      
      </pre><p>
      You can now embed (or run on a standalone server) this business process, by using the 
      familiar jBPM API operations. For example, process instances can now be started using the 
      key (ie. the process id for BPMN 2.0):
      </p><pre class="programlisting">
ProcessInstance pi = executionService.startProcessInstanceByKey("vacationRequestProcess");      
      </pre><p>
      Or tasks list can be retrieved:
      </p><pre class="programlisting">
Task requestTasktask = taskService.createTaskQuery().candidate("peter").uniqueResult();      
      </pre><p>
    </p><p>
      When deploying to the jBPM console database, you should see our new business process popping up.
      </p><div class="mediaobject" align="center"><img src="images/bpmn2.vacationrequest.example.console.01.png" align="middle"/></div><p>
      
      After you start a new process, a new task should be available in the employee's tasklist.
      When clicking on 'view', the task form will be displayed, requesting to fill in some
      variables for further use in the process.
      </p><div class="mediaobject" align="center"><img src="images/bpmn2.vacationrequest.example.console.02.png" align="middle"/></div><p>
      
      After task completion, the manager will find a new verification task in his task list.
      He can now accept or reject the vacation request, based on the input of the employee.
     </p><div class="mediaobject" align="center"><img src="images/bpmn2.vacationrequest.example.console.03.png" align="middle"/></div><p>
     
     Since the database schema remains unchanged when we added BPMN 2.0 on top of the jBPM PVM, all
     existing reports can be applied to our new BPMN 2.0 processes.
      </p><div class="mediaobject" align="center"><img src="images/bpmn2.vacationrequest.example.console.04.png" align="middle"/></div><p>
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="migrationfromjbpm3"/>Chapter 4. Migration from jBPM 3</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2785">4.1. Goals of jBPM 4</a></span></dt><dt><span class="section"><a href="#d0e2799">4.2. Known limitations</a></span></dt><dt><span class="section"><a href="#processconversiontool">4.3. Process conversion tool</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2840">4.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e2850">4.3.2. Arguments</a></span></dt><dt><span class="section"><a href="#d0e2862">4.3.3. Usage examples</a></span></dt><dt><span class="section"><a href="#d0e2867">4.3.4. Advanced</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2875">4.4. Translations and changes</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2785"/>4.1. Goals of jBPM 4</h2></div></div></div><p>In building jBPM 4, we have pursued 2 major goals:</p><div class="itemizedlist"><ul><li><span class="bold"><strong>Improve supportability:</strong></span> In jBPM 3 we relied only on community 
      feedback for improving stability and portability.  In jBPM 4 we have added 
      a clear indication of which environments and configurations that we support. 
      Those environments will be backed with continuous integration in the JBoss QA 
      Labs.  The build now supports all these environments and configurations so that
      it is easier for us to reproduce and investigate problems if they pop up.
      This coverage will also guarantee longer lifespan of jBPM 4.
      </li><li><span class="bold"><strong>Lowering the treshold and increasing adoption to the next level:</strong></span>
      In jBPM 4 we created a clear differentiation between the common, basic usage on the 
      one hand and the advanced usage on the other hand.  So it will be easier to 
      get started and harder (but still possible) to leverage the bleeding edge stuff
      on which developers can burn their fingers.
      </li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2799"/>4.2. Known limitations</h2></div></div></div><p>As part of creating a clear separation between basic and advanced usage, the API 
    has been completely revisited.  Basic usage is covered with the public API.  The same API 
    is available in all the supported environments.  Package names in jBPM 4 are strictly 
    separated from package names in jBPM 3.
    </p><p>Instead of providing a full DB migration, we opted for a strategy to 
    allow for jBPM 3 and jBPM 4 instances to run concurrently next to each 
    other. The table prefix is changed from <code class="literal">JBPM_</code> to <code class="literal">JBPM4_</code>.  
    There is no migration tool to convert jBPM 3 runtime database contents 
    to jBPM 4.  We're not sure if we'll be able to build such a tool in one of the
    next version.  One of the main reasons is that any QA for a data migration of the
    DB contents would be impossible for the project team to achieve.  
    </p><p>Furthermore, there are some features that are not yet available 
    on jBPM 4.  They are ordered from likely to unlikely to get implemented in 
    jBPM 4.
    </p><div class="itemizedlist"><ul><li>User provided transasctional resources such as JDBC connections 
      or hibernate connections</li><li>Exception handlers</li><li>Transient variables</li><li>Identity expression to calculate the assignee of a task</li><li>Task form variable-to-parameter conversions</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="processconversiontool"/>4.3. Process conversion tool</h2></div></div></div><p>In many cases, a lot of work has been put in the design of JPDL3 process
    definitions. To avoid a complete manual translation of these processes to the
    JPDL4 format, the jBPM distribution contains a subdirectory called
    <span class="bold"><strong>migration</strong></span>, which contains a command-line
    tool for converting JPDL3 process definition files to JPDL process XML files.
    </p><p>Translated processes might not be executable any more.  The jBPM 4 
    features might still be missing or the translation itself might not yet 
    be implemented.  But the tedious work of reformatting will be handled 
    by the tool.  It will also indicate the parts that it can't translate. 
    </p><p>
    The tool itself uses only dom4j to do the translation between
    the two formats and should be easy extensible (the source code is also in
    the same directory). The design of the tool is deliberately kept very simple
    (ie most of the logic can be found in the <span class="bold"><strong>Jpdl3Converter</strong></span> class).
    Note that this tool is experimental and tested only a small set of JPDL3 
    process files. 
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2840"/>4.3.1. Overview</h3></div></div></div><p>
      The jPDL Conversion tool takes a jpdl3 process file as input, and 
      converts it to a jpdl4 process file.
    </p><p>    
      Syntax:
      </p><pre class="programlisting">java org.jbpm.jpdl.internal.convert.JpdlConverterTool -v -o &lt;outputfile&gt; &lt;processfile&gt;</pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2850"/>4.3.2. Arguments</h3></div></div></div><div class="itemizedlist"><ul><li><span class="bold"><strong>-v (verbose):</strong></span> The tool will print the detail 
          messages while converting the process file. When this argument is used,
           it will also print the error stacktrace if exceptions are thrown.
        </li><li><span class="bold"><strong>-o (output)</strong></span> Specifies the output file name.
          By default, the tool will generate a file name ending in 'converted.jpdl.xml' 
          using as a base file name the name derived from the input process file.
          The output-filename can be an absolute file name path or a relative file name path.
        </li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2862"/>4.3.3. Usage examples</h3></div></div></div><pre class="programlisting">
java -jar jpdl-migration-XX.jar simple.jpdl.xml
java -jar jpdl-migration-XX.jar -v simple.jpdl.xml
java -jar jpdl-migration-XX.jar -o /home/scott/simple.converted.xml simple.jpdl.xml   
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2867"/>4.3.4. Advanced</h3></div></div></div><p>
        The conversion tool can easily be integrated with regular Java code
        (or with Maven or Ant). The following code example shows how to call the
        internal api to convert the process file:
        </p><pre class="programlisting">
URL url = new URL("simple.jpdl");
Jpdl3Converter jpdlConverter = new Jpdl3Converter(url);
Document jpdl4Doc = jpdlConverter.readAndConvert();

for (Problem problem : jpdlConverter.problems) {
   //do something to handle the problem
}

Writer fileWriter = new FileWriter(outputFile);
OutputFormat format = OutputFormat.createPrettyPrint();
XMLWriter writer = new XMLWriter( fileWriter, format );
writer.write(jpdl4Doc);
writer.close();</pre><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2875"/>4.4. Translations and changes</h2></div></div></div><p>This section gives an indication of the most important renamings and changes that 
    were applied in jBPM4
    </p><div class="table"><a id="d0e2880"/><p class="title"><b>Table 4.1. General name changes</b></p><div class="table-contents"><table summary="General name changes" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>jBPM 3</th><th>jBPM 4</th><th>Remarks</th></tr></thead><tbody><tr><td>Node</td><td>Activity</td></tr><tr><td>Token</td><td>Execution</td><td>The root execution is now the same object as the 
           process instance.  (In jBPM 3, the ProcessInstance had 
           a pointer to the root token).  Also, unlike in jBPM 3, executions in jBPM 4 might 
           get inactivated, create a child execution and let the child execution continue, even 
           when logically this represents only one single path of execution.  This happens in 
           scope activities (or composite activities) that have timers or variables declared.
           </td></tr><tr><td>Action</td><td>Event listener</td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="d0e2910"/><p class="title"><b>Table 4.2. jPDL XML changes</b></p><div class="table-contents"><table summary="jPDL XML changes" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>jBPM 3</th><th>jBPM 4</th></tr></thead><tbody><tr><td>process-definition</td><td>process</td></tr><tr><td>event type="..."</td><td>on event="..."</td></tr><tr><td>action</td><td>event-listener</td></tr><tr><td>node</td><td>custom</td></tr><tr><td>process-state</td><td>sub-process</td></tr><tr><td>super-state</td><td>group (still in incubation)</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="d0e2951"/><p class="title"><b>Table 4.3. Default changes</b></p><div class="table-contents"><table summary="Default changes" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>jBPM 3</th><th>jBPM 4</th></tr></thead><tbody><tr><td>by default, propagated events trigger actions in outer process elements</td><td>by default, propagated events <span class="bold"><strong>do not</strong></span> 
           invoke event-listeners in outer elements, but only in the element on which the 
           event listener is subscribed.</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="processvirtualmachine"/>Chapter 5. The Process Virtual Machine</h2></div></div></div><p>To accomodate multiple process languages and activity pluggability, jBPM is based on 
  the Process Virtual Machine.  In essence, the Process Virtual Machine is a framework specifying 
  executable graphs.  A process definition represents an execution flow 
  and has a structure that be represented graphically as a diagram.    
  </p><p>The Process Virtual Machine separates the structure from a process definition from 
  the activity behaviours.  The Process Virtual Machine takes the execution of a process from 
  one activity to the next and delegates the behaviour of the activities to pluggable Java classes.
  There is an API (<code class="literal">ActivityBehaviour</code>) that serves as the interface between 
  the Process Virtual Machine and the activity behaviour code.  Languages like jPDL are 
  merely a set of ActivityBehaviour implementations and a parser.   
  </p><div class="figure"><a id="example.process.graph"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.loan.png" align="middle" alt="Example process definition"/></div></div><p class="title"><b>Figure 5.1. Example process definition</b></p></div><br class="figure-break"/><p>Typically, process definitions are static.  A process definition is composed of 
  activities and transitions.  The runtime behaviour of a activity is encapsulated in a so called 
  Activity and it's decoupled from the process graph structure.  
  </p><div class="figure"><a id="class.diagram.process.definition"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/class.diagram.process.definition.png" align="middle" alt="Process structure class diagram"/></div></div><p class="title"><b>Figure 5.2. Process structure class diagram</b></p></div><br class="figure-break"/><p>The Process Virtual 
  Machine doesn't contain any such activity implementations.  It only provides the 
  execution environment and an activity API to write <code class="literal">ActivityBehaviour</code> 
  implementations as Java components.  Activities can also be wait states.  This means 
  that the activity control flow goes outside the process system. For example a human task 
  or invoking an service asynchronously.  While the execution is waiting, the runtime state 
  of that execution can be persisted in a DB.
  </p><p>Many executions can be started for one process definition. An execution is a pointer 
  that keeps track of the current activity.
  </p><div class="figure"><a id="example.execution"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/loan.execution.png" align="middle" alt="Example execution"/></div></div><p class="title"><b>Figure 5.3. Example execution</b></p></div><br class="figure-break"/><p>To represent concurrent paths of execution, there is 
  a hierarchical parent-child relation between so that one process instance can cope with concurrent 
  paths of execution.
  </p><div class="figure"><a id="class.diagram.process.execution"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/class.diagram.process.execution.png" align="middle" alt="Execution class diagram"/></div></div><p class="title"><b>Figure 5.4. Execution class diagram</b></p></div><br class="figure-break"/></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Chapter 6. Architecture</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#apis">6.1. APIs</a></span></dt><dt><span class="section"><a href="#d0e3040">6.2. Activity API</a></span></dt><dt><span class="section"><a href="#d0e3054">6.3. Event listener API</a></span></dt><dt><span class="section"><a href="#d0e3061">6.4. Client API</a></span></dt><dt><span class="section"><a href="#d0e3068">6.5. Environment</a></span></dt><dt><span class="section"><a href="#d0e3095">6.6. Commands</a></span></dt><dt><span class="section"><a href="#d0e3103">6.7. Services</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="apis"/>6.1. APIs</h2></div></div></div><p>The Process Virtual Machine has 4 integrated API's that together 
    offer a complete coverage of working with processes in the different execution modes.  
    Each of the APIs has a specific purpose that fits within the following overall 
    architecture.
    </p><div class="figure"><a id="apis"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/apis.png" align="middle" alt="The 4 API's of the Process Virtual Machine"/></div></div><p class="title"><b>Figure 6.1. The 4 API's of the Process Virtual Machine</b></p></div><br class="figure-break"/><p>The services interfaces should be used from application code that wants to interact 
    with the Process Virtual Machine which runs in transactional persistent mode, backed by a 
    database.  This is the most typical way how users interact with the PVM as a workflow engine.
    </p><p>To execute processes without persistence, the client API can be used to work with process 
    and execution objects directly.  The client API expose the methods of the core model objects.
    </p><p>The activity API is used to implement the runtime behaviour of activities.  So a activity 
    type is in fact a component with at the core an implementation of the <code class="literal">ActivityBehaviour</code> 
    interface.  ActivityBehaviour implementations can control the flow of execution.
    </p><p>The event listener API serves to write pieces of Java code that should be executed upon 
    process events.  It's very similar to the activity API with that exception that event listeners
    are not able to control the flow of execution. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3040"/>6.2. Activity API</h2></div></div></div><p>The activity API allows to implement the runtime activity behaviour in Java.
    </p><pre class="programlisting">public interface ActivityBehaviour extends Serializable {
  void execute(ActivityExecution execution) throws Exception;
}</pre><p>An activity is the behaviour of the activity to which it is associated.
    The provided execution is the execution that arrives in the activity.
    The interface <code class="literal">ActivityExecution</code> exposes special 
    methods to control the execution flow.
    </p><pre class="programlisting">public interface ActivityExecution extends OpenExecution {

  void waitForSignal();
  void take(String transitionName);
  void execute(String activityName);

  ...

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3054"/>6.3. Event listener API</h2></div></div></div><p>The event listener API allows for listeners to be developed in Java code 
    and that are invoked on specific process events like entering a activity or leaving 
    a activity.  It is very similar to the activity API, but the difference is  
    that the propagation of the execution flow cannot be controlled.  E.g. when an execution 
    is taking a transition, a listener to that event can be notified, but since the 
    transition is already being taking, the execution flow cannot be changed 
    by the event listeners.  
    </p><pre class="programlisting">public interface EventListener extends Serializable {
  
  void notify(EventListenerExecution execution) throws Exception;

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3061"/>6.4. Client API</h2></div></div></div><p>The client API is the interface that exposes the methods for 
    managing executions on the plain process definition and execution objects directly. 
    </p><p>At a minimal, the client API and the activity API are needed to create 
    some a process definition with activities and execute it.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3068"/>6.5. Environment</h2></div></div></div><p>In the persistent execution mode, the first purpose of the environment is 
    to enable processes to be executed in different transactional environments like 
    standard Java, enterprise Java, SEAM and Spring.
    </p><p>The PVM code itself will only use transactional resources through self-defined 
    interfaces.  For example, the PVM itself has interfaces for some methods on the hibernate 
    session, a async messaging session and a timer session.
    </p><p>The environment allows to configure the actual implementations, lazy 
    initialization of the services on a request-basis and caching the service 
    objects for the duration of the transaction. 
    </p><p>An environment factory is static and one environment factory can serve 
    all the threads in an application.
    </p><pre class="programlisting">EnvironmentFactory environmentFactory = new PvmEnvironmentFactory("environment.cfg.xml");</pre><p>Environment blocks can surround persistent process operations 
    like this:
    </p><pre class="programlisting">Environment environment = environmentFactory.openEnvironment();
try {

  ... inside the environment block...

} finally {
  environment.close();
}</pre><p>The PVM itself will fetch all it's transactional resources and configurations 
    from the environment.  It's recommended that <code class="literal">Activity</code> implementations
    do the same.
    </p><p>The <code class="literal">org.jbpm.pvm.internal.cfg.JbpmConfiguration</code> acts as Configuration, 
    ProcessEngine and EnvironmentFactory.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3095"/>6.6. Commands</h2></div></div></div><p>Commands encapsulate operations that are to be executed within an environment 
    block.  The main purpose for commands is to capture the logic of 
    </p><pre class="programlisting">public interface Command&lt;T&gt; extends Serializable {

  T execute(Environment environment) throws Exception;

}</pre><p/></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3103"/>6.7. Services</h2></div></div></div><p>There are three main services: <code class="literal">RepositoryService</code>, 
    <code class="literal">ExecutionService</code> and <code class="literal">ManagementService</code>.
    In general, services are session facades that expose methods for persistent 
    usage of the PVM. The next fragments show the essential methods as example 
    to illustrate those services. 
    </p><p>The <code class="literal">RepositoryService</code> manages the repository of 
    process definitions.
    </p><pre class="programlisting">public interface RepositoryService {

  Deployment createDeployment();

  ProcessDefinitionQuery createProcessDefinitionQuery();
  
  ...

}</pre><p>The <code class="literal">ExecutionService</code> manages the runtime 
    executions.</p><pre class="programlisting">public interface ExecutionService {

  ProcessInstance startProcessInstanceById(String processDefinitionId);

  ProcessInstance signalExecutionById(String executionId);
   
  ...

}</pre><p>The <code class="literal">ManagementService</code> groups all management operations
    that are needed to keep the system up and running.
    </p><pre class="programlisting">public interface ManagementService {

  JobQuery createJobQuery();

  void executeJob(long jobDbid);
  
  ...
  
}</pre><p>The implementation of all these methods is encapsulated in 
    <code class="literal">Command</code>s.  And the three services all delegate the 
    execution of the commands to a <code class="literal">CommandService</code>:
    </p><pre class="programlisting">public interface CommandService {

  &lt;T&gt; T execute(Command&lt;T&gt; command);

}</pre><p>The <code class="literal">CommandService</code> is configured in the 
    environment.  A chain of CommandServices can act as interceptors 
    around a command.  This is the core mechanism on how persistence and 
    transactional support can be offered in a variety of environments.
    </p><p>The default configuration file <code class="literal">jbpm.default.cfg.xml</code> 
    includes following section that configures the services
    </p><pre class="programlisting">&lt;jbpm-configuration&gt;

  &lt;process-engine&gt;
  
    &lt;repository-service /&gt;
    &lt;repository-cache /&gt;
    &lt;execution-service /&gt;
    &lt;history-service /&gt;
    &lt;management-service /&gt;
    &lt;identity-service /&gt;
    &lt;task-service /&gt;</pre><p>And the file <code class="literal">jbpm.tx.hibernate.cfg.xml</code> contains the 
    following command service configuration:</p><pre class="programlisting">&lt;jbpm-configuration&gt;

  &lt;process-engine-context&gt;
    &lt;command-service&gt;
      &lt;retry-interceptor /&gt;
      &lt;environment-interceptor /&gt;
      &lt;standard-transaction-interceptor /&gt;
    &lt;/command-service&gt;
  &lt;/process-engine-context&gt;

  ...</pre><p>The services like e.g. <code class="literal">repository-service</code>, <code class="literal">execution-service</code>
    and <code class="literal">management-service</code> will look up the configured 
    <code class="literal">command-service</code> by type.  The <code class="literal">command-service</code>
    tag corresponds to the default command service that essentially does nothing else 
    then just execute the command providing it the current environment.
    </p><p>The configured <code class="literal">command-service</code> results into the following 
    a chain of three interceptors followed by the default command executor. 
    </p><div class="figure"><a id="interceptors"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/interceptors.png" align="middle" alt="The CommandService interceptors"/></div></div><p class="title"><b>Figure 6.2. The CommandService interceptors</b></p></div><br class="figure-break"/><p>The retry interceptor is the first in the chain and that one that will be exposed as the 
    <code class="literal">CommandService.class</code> from the environment.  So the retry interceptor 
    will be given to the respective services <code class="literal">repository-service</code>, <code class="literal">execution-service</code>
    and <code class="literal">management-service</code>.  
    </p><p>The <code class="literal">retry-interceptor</code> will catch hibernate StaleObjectExceptions 
    (indicating optimistic locking failures) and retry to execute the command.
    </p><p>The <code class="literal">environment-interceptor</code> will put an environment block 
    around the execution of the command.
    </p><p>The <code class="literal">standard-transaction-interceptor</code> will initialize a 
    <code class="literal">StandardTransaction</code>.  The hibernate session/transaction will be 
    enlisted as a resource with this standard transaction.
    </p><p>Different configurations of this interceptor stack will also enable to 
    </p><div class="itemizedlist"><ul><li>delegate execution to a local ejb command service so that an container 
      managed transaction is started.
      </li><li>delegate to a remote ejb command service so that the command actually 
      gets executed on a different JVM.
      </li><li>package the command as an asynchronous message so that the command gets 
      executed asynchronously in a different transaction.
      </li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="implementingbasicactivities"/>Chapter 7. Implementing basic activities</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#activity">7.1. ActivityBehaviour</a></span></dt><dt><span class="section"><a href="#activitybehaviourexample">7.2. ActivityBehaviour example</a></span></dt><dt><span class="section"><a href="#externalactivitybehaviour">7.3. ExternalActivityBehaviour</a></span></dt><dt><span class="section"><a href="#externalactivityexample">7.4. ExternalActivity example</a></span></dt><dt><span class="section"><a href="#basicprocessexecution">7.5. Basic process execution</a></span></dt><dt><span class="section"><a href="#events">7.6. Events</a></span></dt><dt><span class="section"><a href="#d0e3719">7.7. Event propagation</a></span></dt></dl></div><p>This chapter explains the basics of process definitions, the features offered by 
  the Process Virtual Machine and how activity implementations can be build.   At the same 
  time the client API is shown to execute processes with those activity implementations.  
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="activity"/>7.1. ActivityBehaviour</h2></div></div></div><p>The PVM library doesn't have a fixed set of process constructs. 
    Instead, runtime behaviour of a activity is delegated to an <code class="literal">ActivityBehaviour</code>.  
    In other words, <code class="literal">ActivityBehaviour</code> is an interface to implement the runtime 
    behaviour of process constructs in plain Java.
    </p><pre class="programlisting">public <span class="bold"><strong>interface ActivityBehaviour</strong></span> extends Serializable {
    
  void <span class="bold"><strong>execute</strong></span>(ActivityExecution execution) throws Exception;
  
}</pre><p>When an activity behaviour is called, it is in full control of the further 
    propagation of the execution.  In other words, an activity behaviour can decide what the execution 
    should do next.  For example, it can take a transition with 
    <code class="literal">execution.take(Transition)</code> or go into a wait state with 
    <code class="literal">execution.waitForSignal()</code>.  In case the activity behaviour does not invoke 
    any of the above execution propagation methods, the execution will 
    <a href="#implicitproceedbehaviour" title="9.2. Implicit proceed behaviour">proceed in a default way</a>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="activitybehaviourexample"/>7.2. ActivityBehaviour example</h2></div></div></div><p>We'll start with a very original hello world example.  A Display 
    activity will print a message to the console:
    </p><pre class="programlisting">public <span class="bold"><strong>class Display</strong></span> implements <span class="bold"><strong>ActivityBehaviour</strong></span> {

  String message;

  public Display(String message) {
    this.message = message;
  }

  public void execute(ActivityExecution execution) {
    <span class="bold"><strong>System.out.println(message);</strong></span>
  }
}</pre><p>Let' build our first process definition with this activity:</p><div class="figure"><a id="activity.example"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.ab.png" align="middle" alt="Display example process"/></div></div><p class="title"><b>Figure 7.1. Display example process</b></p></div><br class="figure-break"/><pre class="programlisting">TODO add ProcessBuilder example code</pre><p>Now we can execute this process as follows:</p><pre class="programlisting">Execution execution = processDefinition.startExecution();</pre><p>The invocation of <code class="literal">startExecution</code> will print hello world to the console:</p><pre class="programlisting">hello
world</pre><p>One thing already worth noticing is that activities can be configured 
    with properties.  In the Display example, you can see that the message property 
    is configured differently in the two usages.  With configuration properties 
    it becomes possible to write reusable activities. They can then be configured 
    differently each time they are used in a process.  That is an essential part of 
    how process languages can be build on top of the Process Virtual Machine.
    </p><p>The other part that needs explanation is that this activity 
    implementation does not contain any instructions for the propagation of the
    execution.  When a new process instance is started, the execution is positioned
    in the initial activity and that activity is executed.  The method 
    <code class="literal">Display.execute</code> makes use of what is called implicit propagation 
    of execution.  Concretely this means that the activity itself does not 
    invoke any of the methods on the execution to propagate it.  In that case 
    implicit propagation kicks in.  Implicit propagation will take the first 
    transition if there is one.  If not, it will end the execution.  This explains 
    why both activities <code class="literal">a</code> and <code class="literal">b</code> are executed and that 
    the execution stops after activity <code class="literal">b</code> is executed. 
    </p><p>More details about the implicit proceed behaviour can be found 
    in <a href="#implicitproceedbehaviour" title="9.2. Implicit proceed behaviour">Section 9.2, “Implicit proceed behaviour”</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="externalactivitybehaviour"/>7.3. ExternalActivityBehaviour</h2></div></div></div><p>External activities are activities for which the responsibility for proceeding 
    the execution is transferred externally, meaning outside the process system. This 
    means that for the system that is executing the process, it's a wait state.  The 
    execution will wait until an external trigger is given.  
    </p><p>For dealing with external triggers, <code class="literal">ExternalActivityBehaviour</code> 
    adds one method to the <code class="literal">ActivityBehaviour</code>:</p><pre class="programlisting">public <span class="bold"><strong>interface ExternalActivity</strong></span> extends <span class="bold"><strong>Activity</strong></span> {

  void <span class="bold"><strong>signal</strong></span>(Execution execution,
              String signal, 
              Map&lt;String, Object&gt; parameters) throws Exception;
              
}</pre><p>Just like with plain activities, when an execution arrives in a activity, the 
    <code class="literal">execute</code>-method of the external activity behaviour is invoked.
    In external activities, the execute method typically does something to 
    transfer the responsibility to another system and then enters a wait 
    state by invoking <code class="literal">execution.waitForSignal()</code>.  For 
    example in the execute method, responsibility could be transferred to a 
    person by creating a task entry in a task management system and then
    wait until the person completes the task.
    </p><p>In case a activity behaves as a wait state, then the execution will 
    wait in that activity until the execution's <code class="literal">signal</code> method 
    is invoked.  The execution will delegate that signal to the ExternalActivityBehaviour
    object associated to the current activity.
    </p><p>So the Activity's <code class="literal">signal</code>-method is invoked 
    when the execution receives an external trigger during the wait state.  With the 
    signal method, responsibility is transferred back to the process execution. For 
    example, when a person completes a task, the task management system calls the 
    signal method on the execution.
    </p><p>A signal can optionally have a signal name and a map of parameters.  Most 
    common way on how activity behaviours interprete the signal and parameters is that 
    the signal relates to the outgoing transition that needs to be taken and that the 
    parameters are set as variables on the execution. But those are just examples, it 
    is up to the activity to use the signal and the parameters as it pleases.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="externalactivityexample"/>7.4. ExternalActivity example</h2></div></div></div><p>Here's a first example of a simple wait state implementation:
    </p><pre class="programlisting">public <span class="bold"><strong>class WaitState</strong></span> implements <span class="bold"><strong>ExternalActivity</strong></span> {

  public void execute(ActivityExecution execution) {
    <span class="bold"><strong>execution.waitForSignal();</strong></span>
  }

  public void signal(ActivityExecution execution, 
                     String signalName, 
                     Map&lt;String, Object&gt; parameters) {
    <span class="bold"><strong>execution.take(signalName);</strong></span>
  }
}</pre><p>The <code class="literal">execute</code>-method calls 
    <code class="literal">execution.waitForSignal()</code>.  The invocation of 
    <code class="literal">execution.waitForSignal()</code> will bring the process execution 
    into a wait state until an external trigger is given. 
    </p><p><code class="literal">signal</code>-method takes the transition with 
    the signal parameter as the transition name.  So when an execution receives an 
    external trigger, the signal name is interpreted as the name of an outgoing
    transition and the execution will be propagated over that transition.
    </p><p>Here's the same simple process that has a transition from a to b.  This 
    time, the behaviour of the two activities will be WaitState's.
    </p><div class="figure"><a id="process.diagram"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.ab.png" align="middle" alt="The external activity example process"/></div></div><p class="title"><b>Figure 7.2. The external activity example process</b></p></div><br class="figure-break"/><pre class="programlisting">ClientProcessDefinition processDefinition = ProcessFactory.build()
    <span class="bold"><strong>.activity("a").initial().behaviour(new WaitState())</strong></span>
      .transition().to("b")
    <span class="bold"><strong>.activity("b").behaviour(new WaitState())</strong></span>
.done();</pre><p>Let's start a new process instance for this process definition:</p><pre class="programlisting">ClientExecution execution = processDefinition.startProcessInstance();</pre><p>Starting this process will execute the <code class="literal">WaitState</code> activity 
    in activity <code class="literal">a</code>.  <code class="literal">WaitState.execute</code> will invoke 
    <code class="literal">ActivityExecution.waitForSignal</code>.  So when the 
    <code class="literal">processDefinition.startProcessInstance()</code> returns, the execution 
    will still be positioned in activity a.  
    </p><pre class="programlisting">assertEquals("a", execution.getActivityName());</pre><p>Then we provide the external trigger by calling the <code class="literal">signal</code> 
    method.
    </p><pre class="programlisting">execution.signal();</pre><p>The <code class="literal">execution.signal()</code> will delegate to the activity 
    of the current activity.  So in this case that is the <code class="literal">WaitState</code>
    activity in activity <code class="literal">a</code>.  The <code class="literal">WaitState.signal</code>
    will invoke the <code class="literal">ActivityExecution.take(String transitionName)</code>.
    Since we didn't supply a signalName, the first transition with name <code class="literal">null</code>
    will be taken.  The only transition we specified out of activity <code class="literal">a</code> 
    didn't get a name so that one will be taken.  And that transition points to activity 
    <code class="literal">b</code>.  When the execution arrives in activity <code class="literal">b</code>,
    the <code class="literal">WaitState</code> in activity <code class="literal">b</code> is executed. 
    Similar as we saw above, the execution will wait in activity <code class="literal">b</code>
    and this time the <code class="literal">signal</code> method will return, leaving the 
    execution positioned in activity <code class="literal">b</code>.  
    </p><pre class="programlisting">assertEquals("b", execution.getActivityName());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="basicprocessexecution"/>7.5. Basic process execution</h2></div></div></div><p>In this next example, we'll combine automatic activities and wait states.
    This example builds upon the loan approval process with the <code class="literal">WaitState</code>
    and <code class="literal">Display</code> activities that we've just created.  Graphically,
    the loan process looks like this:  
    </p><div class="figure"><a id="basicprocessexecution.loan.process"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.loan.png" align="middle" alt="The loan process"/></div></div><p class="title"><b>Figure 7.3. The loan process</b></p></div><br class="figure-break"/><p>Building process graphs in Java code can be tedious because you have to keep track of all the 
    references in local variables.  To resolve that, the Process Virtual Machine comes with a 
    ProcessFactory.  The ProcessFactory is a kind of domain specific language (DSL) that is embedded 
    in Java and eases the construction of process graphs.  This pattern is also known as 
    a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://martinfowler.com/bliki/FluentInterface.html">fluent 
    interface</a>.    
    </p><pre class="programlisting">ClientProcessDefinition processDefinition = ProcessFactory.build("loan")
  .activity(<span class="bold"><strong>"submit loan request"</strong></span>).initial().behaviour(new Display("loan request submitted"))
    .transition().to("evaluate")
  <span class="bold"><strong>.activity("evaluate").behaviour(new WaitState())</strong></span>
    .transition("approve").to("wire money")
    .transition("reject").to("end")
  <span class="bold"><strong>.activity("wire money").behaviour(new Display("wire the money"))</strong></span>
    .transition().to("archive")
  <span class="bold"><strong>.activity("archive").behaviour(new WaitState())</strong></span>
    .transition().to("end")
  <span class="bold"><strong>.activity("end").behaviour(new WaitState())</strong></span>
.done();</pre><p>For more details about the ProcessFactory, see <a xmlns:xlink="http://www.w3.org/1999/xlink" href="../../api/org/jbpm/pvm/package-summary.html">the
    api docs</a>.  An alternative for 
    the ProcessFactory would be to create an XML language and an XML parser for expressing 
    processes.  The XML parser can then instantiate the classes of package 
    <code class="literal">org.jbpm.pvm.internal.model</code> directly. That approach is typically taken by 
    process languages.  
    </p><p>The initial activity <code class="literal">submit loan request</code> and the activity 
    <code class="literal">wire the money</code> are automatic activities.  In this example, 
    the <code class="literal">Display</code> implementation of activity 
    <code class="literal">wire the money</code> uses the Java API's to just print a 
    message to the console.  But the witty reader can imagine an alternative 
    <code class="literal">Activity</code> implementation that uses the Java API of a payment 
    processing library to make a real automatic payment.  
    </p><p>A new execution for the process above can be started like this
    </p><pre class="programlisting">ClientExecution execution = processDefinition.startProcessInstance();</pre><p>When the <code class="literal">startExecution</code>-method returns, the activity 
    <code class="literal">submit loan request</code> will be executed and the execution will be 
    positioned in the activity <code class="literal">evaluate</code>.
    </p><div class="figure"><a id="execution.loan.evaluate"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/execution.loan.evaluate.png" align="middle" alt="Execution positioned in the 'evaluate' activity"/></div></div><p class="title"><b>Figure 7.4. Execution positioned in the 'evaluate' activity</b></p></div><br class="figure-break"/><p>Now, the execution is at an interesting point.  There are two transitions out of 
    the state <code class="literal">evaluate</code>.  One transition is called <code class="literal">approve</code> 
    and one transition is called <code class="literal">reject</code>.  As we explained above, the WaitState
    implementation will take the transition that corresponds to the signal that is given.  
    Let's feed in the 'approve' signal like this:
    </p><pre class="programlisting">execution.signal("approve");</pre><p>The <code class="literal">approve</code> signal will cause the execution to take the <code class="literal">approve</code>
    transition and it will arrive in the activity <code class="literal">wire money</code>.
    </p><p>In activity <code class="literal">wire money</code>, the message will be printed to the console.
    Since, the <code class="literal">Display</code> activity didn't invoke the 
    <code class="literal">execution.waitForSignal()</code>, nor any of the other execution propagation 
    methods, the implicit proceed behaviour will just make the execution continue 
    over the outgoing transition to activity <code class="literal">archive</code>, which is again 
    a <code class="literal">WaitState</code>.
    </p><div class="figure"><a id="execution.loan.archive"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/execution.loan.archive.png" align="middle" alt="Execution positioned in 'archive' activity"/></div></div><p class="title"><b>Figure 7.5. Execution positioned in 'archive' activity</b></p></div><br class="figure-break"/><p>So only when the <code class="literal">archive</code> wait state is reached, 
    the <code class="literal">signal("approve")</code> returns.   
    </p><p>Another signal like this:</p><pre class="programlisting">execution.signal("approve");</pre><p>will bring the execution eventually in the end state.</p><div class="figure"><a id="execution.loan.end"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/execution.loan.end.png" align="middle" alt="Execution positioned in the 'end' activity"/></div></div><p class="title"><b>Figure 7.6. Execution positioned in the 'end' activity</b></p></div><br class="figure-break"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="events"/>7.6. Events</h2></div></div></div><p>Events are points in the process definition to which a list of 
    <code class="literal">EventListener</code>s can be subscribed. 
    </p><pre class="programlisting">public interface EventListener extends Serializable {
  
  void notify(EventListenerExecution execution) throws Exception;

}</pre><p>The motivation for events is to allow for 
    developers to add programming logic to a process without changing the process diagram.  
    This is a very valuable instrument in facilitating the collaboration between business analysts 
    and developers.  Business analysts
    are responsible for expressing the requirements.  When they use a process graph to document 
    those requirements, developers can take this diagram and make it executable.  Events can 
    be a very handy to insert technical details into a process (like e.g. some database insert) 
    in which the business analyst is not interested.   
    </p><p>Most common events are fired by the execution automatically:
    </p><p>TODO: explain events in userguide</p><p>Events are identified by the combination of a process element 
    and an event name.  Users and process languages can also fire events 
    programmatically with the fire method on the Execution:
    </p><pre class="programlisting">public interface Execution extends Serializable {
  ...
  void fire(String eventName, ProcessElement eventSource);
  ...
}</pre><p>A list of <code class="literal">EventListeners</code> can be associated to an 
    event. But event listeners can not influence the control flow of the execution since 
    they are merely listeners to an execution which is already in progress.  This is different from 
    activities that serve as the behaviour for activities.  Activity behaviour activities are responsible 
    for propagating the execution. 
    </p><p>We'll create a <code class="literal">PrintLn</code> event listener which is 
    very similar to the <code class="literal">Display</code> activity from above.
    </p><pre class="programlisting">public class PrintLn implements EventListener {
  
  String message;
  
  public PrintLn(String message) {
    this.message = message;
  }

  public void notify(EventListenerExecution execution) throws Exception {
    System.out.println("message");
  }
}</pre><p>Several <code class="literal">PrintLn</code> listeners will be subscribed to events in 
    the process.</p><div class="figure"><a id="action.process"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.ab.png" align="middle" alt="The PrintLn listener process"/></div></div><p class="title"><b>Figure 7.7. The PrintLn listener process</b></p></div><br class="figure-break"/><pre class="programlisting">ClientProcessDefinition processDefinition = ProcessFactory.build()
  .activity("a").initial().behaviour(new AutomaticActivity())
    <span class="bold"><strong>.event("end")
      .listener(new PrintLn("leaving a"))
      .listener(new PrintLn("second message while leaving a"))</strong></span>
    .transition().to("b")
      <span class="bold"><strong>.listener(new PrintLn("taking transition"))</strong></span>
  .activity("b").behaviour(new WaitState())
    .event("start")
      <span class="bold"><strong>.listener(new PrintLn("entering b"))</strong></span>
.done();</pre><p>The first event shows how to register multiple listeners to the same 
     event.  They will be notified in the order as they are specified.
     </p><p>Then, on the transition, there is only one type of event.  So in that case,
     the event type must not be specified and the listeners can be added directly on 
     the transition.
     </p><p>A listeners will be called each time an execution fires the event to 
     which the listener is subscribed.  The execution will be provided in the activity 
     interface as a parameter and can be used by listeners except for the methods that
     control the propagation of execution.
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3719"/>7.7. Event propagation</h2></div></div></div><p>Events are by default propagated to enclosing process elements.  The motivation 
    is to allow for listeners on process definitions or composite activities that get executed
    for all events that occur within that process element.  For example this feature 
    allows to register an event listener on a process definition or a composite activity on 
    <code class="literal">end</code> events.  Such action will be executed if that activity is 
    left.  And if that event listener is registered on a composite activity, it will also be executed 
    for all activities that are left within that composite activity. 
    </p><p>To show this clearly, we'll create a <code class="literal">DisplaySource</code> event listener
    that will print the message <code class="literal">leaving</code> and the source of the event
    to the console.
    </p><pre class="programlisting">public class <span class="bold"><strong>DisplaySource</strong></span> implements EventListener {
    
  public void execute(EventListenerExecution execution) {
    <span class="bold"><strong>System.out.println("leaving "+execution.getEventSource());</strong></span>
  }
}</pre><p>Note that the purpose of event listeners is not to be visible, that's why the event listener 
    itself should not be displayed in the diagram. A <code class="literal">DisplaySource</code> event listener
    will be added as a listener to the event <code class="literal">end</code> on the composite activity.  
    </p><p>The next process shows how the <code class="literal">DisplaySource</code> event listener is registered 
    as a listener to to the 'end' event on the <code class="literal">composite</code> activity:</p><div class="figure"><a id="process.propagate"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.propagate.png" align="middle" alt="A process with an invisible event listener on a end event on a composite activity."/></div></div><p class="title"><b>Figure 7.8. A process with an invisible event listener on a end event on a composite activity.</b></p></div><br class="figure-break"/><pre class="programlisting">TODO update code snippet</pre><p>Next we'll start an execution.</p><pre class="programlisting">ClientExecution execution = processDefinition.startProcessInstance();</pre><p>After starting a new execution, the execution will be in activity <code class="literal">a</code> as 
    that is the initial activity.  No activities have been left so no message is logged.  Next a signal 
    will be given to the execution, causing it to take the transition from <code class="literal">a</code>
    to <code class="literal">b</code>.
    </p><pre class="programlisting">execution.signal();</pre><p>When the signal method returns, the execution will have taken the transition and 
    the <code class="literal">end</code> event will be fired on activity <code class="literal">a</code>.  That 
    event will be propagated to the 
    composite activity and to the process definition.  Since our <code class="literal">DisplaySource</code> 
    event listener is placed 
    on the <code class="literal">composite</code> activity, it will receive the event and print the following 
    message on the console:
    </p><pre class="programlisting">leaving activity(a)</pre><p>Another</p><pre class="programlisting">execution.signal();</pre><p>will take the transition from b to c.  That will fire two activity-leave events.  One on  
    activity b and one on activity composite.  So the following lines will be appended to the console 
    output:</p><pre class="programlisting">leaving activity(b)
leaving activity(composite)</pre><p>Event propagation is build on the hierarchical composition structure of the process 
    definition.  The top level element is always the process definition.  The process 
    definition contains a list of activities.  Each activity can be a leaf activity or it can be a 
    composite activity, which means that it contains a list of nested activities.  Nested activities 
    can be used for e.g. super states or composite activities in nested process languages like BPEL.    
    </p><p>So the even model also works similarly for composite activities as it did for the process 
    definition above.  Suppose that 'Phase one' models 
    a super state as in state machines.  Then event propagation allows to subscribe to all events 
    within that super state.  The idea is that the hierarchical composition corresponds to 
    diagram representation. If an element 'e' is drawn inside another element 'p', then p 
    is the parent of e. A process definition has a set of top level activities.  Every activity can have 
    a set of nested activities.  The parent of a transition is considered as the first common 
    parent for it's source and destination.  
    </p><p>If an event listener is not interested in propagated events, propagation can be disabled 
    with <code class="literal">propagationDisabled()</code> while building the process with the 
    <code class="literal">ProcessFactory</code>.  The next process is the same process 
    as above except that propagated events will be disabled on the event listener.  The graph diagram
    remains the same.
    </p><div class="figure"><a id="process.propagate.propagation.disabled"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.propagate.png" align="middle" alt="A process with an event listener to 'end' events with propagation disabled."/></div></div><p class="title"><b>Figure 7.9. A process with an event listener to 'end' events with propagation disabled.</b></p></div><br class="figure-break"/><p>Building the process with the process factory:
    </p><pre class="programlisting">TODO update code snippet</pre><p>So when the first signal is given for this process, again the <code class="literal">end</code> 
    event will be fired on activity <code class="literal">a</code>, but now the event listener on the composite 
    activity will not be executed cause 
    propagated events have been disabled.  Disabling propagation is a property on the individual 
    event listener and doesn't influence the other listeners.  The event will always be fired and 
    propagated over the whole parent hierarchy.
    </p><pre class="programlisting">ClientExecution execution = processDefinition.startProcessInstance();</pre><p>The first signal will take the process from <code class="literal">a</code> to 
    <code class="literal">b</code>.  No messages will be printed to the console.
    </p><pre class="programlisting">execution.signal();</pre><p>Next, the second signal will take the transition from b to c.  
    </p><pre class="programlisting">execution.signal()</pre><p>Again two <code class="literal">end</code>
    events are fired just like above on activities <code class="literal">b</code> and <code class="literal">composite</code> 
    respectively.  The first event 
    is the <code class="literal">end</code> event on activity <code class="literal">b</code>.  That will be propagated 
    to the <code class="literal">composite</code> activity.  So the event 
    listener will not be executed for this event cause it has propagation disabled.  But the 
    event listener will be executed for the <code class="literal">end</code> event on the 
    <code class="literal">composite</code> activity.  That is not 
    propagated, but fired directly on the <code class="literal">composite</code> activity.  So the event 
    listener will now be executed 
    only once for the composite activity as shown in the following console output: 
    </p><pre class="programlisting">leaving activity(composite)</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="processanatomy"/>Chapter 8. Process anatomy</h2></div></div></div><p>Above we already touched briefly on the two main process constructs: 
  Activities, transitions and activity composition.  This chapter explores in full 
  all the possibilities of the process definition structures.
  </p><p>There are basically two forms of process languages: graph based and composite 
  process languages.  First of all, the process supports both.  Even graph based execution 
  and activity composition can be used in combination to implement something like UML super states.
  Furthermore, automatic functional activities can be implemented so that they can be 
  used with transitions as well as with activity composition.
  </p><div class="figure"><a id="process.anatomy"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/process.anatomy.classes.png" align="middle" alt="UML class diagram of the logical process structure"/></div></div><p class="title"><b>Figure 8.1. UML class diagram of the logical process structure</b></p></div><br class="figure-break"/><p>By separating the structure of a process from the behaviour of the activities, 
  any process model can be formed in the PVM.  It's up to the activity implementations 
  to use this structure.  Activities can also impose restrictions on the diagram 
  structures they can support.  Typically activities that control process concurrency
  will impose restrictions on the process model structures that they can support.  
  Next we'll show a series of example diagram structures that can be formed 
  with the PVM process model.
  </p><div class="figure"><a id="transition"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transition.png" align="middle" alt="Any two activities can be connected with a transition."/></div></div><p class="title"><b>Figure 8.2. Any two activities can be connected with a transition.</b></p></div><br class="figure-break"/><div class="figure"><a id="self.transition"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/self.transition.png" align="middle" alt="A self transition."/></div></div><p class="title"><b>Figure 8.3. A self transition.</b></p></div><br class="figure-break"/><div class="figure"><a id="composite.activity"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/composite.activity.png" align="middle" alt="Composite activity is a list of nested activities."/></div></div><p class="title"><b>Figure 8.4. Composite activity is a list of nested activities.</b></p></div><br class="figure-break"/><div class="figure"><a id="transition.into.composite"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transition.into.composite.png" align="middle" alt="Transition to a activity inside a composite."/></div></div><p class="title"><b>Figure 8.5. Transition to a activity inside a composite.</b></p></div><br class="figure-break"/><div class="figure"><a id="transition.out.of.composite"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transition.out.of.composite.png" align="middle" alt="Transition from a activity inside a composite to a activity outside the composite."/></div></div><p class="title"><b>Figure 8.6. Transition from a activity inside a composite to a activity outside the composite.</b></p></div><br class="figure-break"/><div class="figure"><a id="transition.inheritence"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transition.inheritence.png" align="middle" alt="Transition of composite activities are inherited. The activity inside can take the transition of the composite activity."/></div></div><p class="title"><b>Figure 8.7. Transition of composite activities are inherited.  The activity inside can take the transition of the composite activity.</b></p></div><br class="figure-break"/><div class="figure"><a id="transition.to.outer"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transition.to.outer.png" align="middle" alt="Transition from a activity to an outer composite."/></div></div><p class="title"><b>Figure 8.8. Transition from a activity to an outer composite.</b></p></div><br class="figure-break"/><div class="figure"><a id="transition.to.inner"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transition.to.inner.png" align="middle" alt="Transition from a composite activity to an inner composed activity."/></div></div><p class="title"><b>Figure 8.9. Transition from a composite activity to an inner composed activity.</b></p></div><br class="figure-break"/><div class="figure"><a id="initial.in.composite"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/initial.in.composite.png" align="middle" alt="An initial activity inside a composite activity."/></div></div><p class="title"><b>Figure 8.10. An initial activity inside a composite activity.</b></p></div><br class="figure-break"/></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="advancedgraphexecution"/>Chapter 9. Advanced graph execution</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3958">9.1. Loops</a></span></dt><dt><span class="section"><a href="#implicitproceedbehaviour">9.2. Implicit proceed behaviour</a></span></dt><dt><span class="section"><a href="#functionalactivities">9.3. Functional activities</a></span></dt><dt><span class="section"><a href="#executionandthreads">9.4. Execution and threads</a></span></dt><dt><span class="section"><a href="#d0e4087">9.5. Process concurrency</a></span></dt><dt><span class="section"><a href="#d0e4127">9.6. Exception handlers</a></span></dt><dt><span class="section"><a href="#d0e4157">9.7. Process modifications</a></span></dt><dt><span class="section"><a href="#d0e4163">9.8. Locking and execution state</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3958"/>9.1. Loops</h2></div></div></div><p>Activities can implement loops based on transitions or on activity composition.  
    Loops can contain wait states.    
    </p><p>To support high numbers of automatic loop executions, the Process Virtual Machine 
    tranformed the propagation of execution from tail recursion to a while loop.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="implicitproceedbehaviour"/>9.2. Implicit proceed behaviour</h2></div></div></div><p>An <code class="literal">ActivityBehaviour</code> can 
    explicitely propagate the execution with following methods:
    </p><div class="itemizedlist"><ul><li><code class="literal">waitForSignal()</code></li><li><code class="literal">take(Transition)</code></li><li><code class="literal">end(*)</code></li><li><code class="literal">execute(Activity)</code></li><li><code class="literal">createExecution(*)</code></li></ul></div><p>As a side note, some of these methods are not exposed in the 
    interfaces, but only in the implementation.  Those methods are still 
    in 'incubation'.  So if you want to use those, you can use them at your 
    own risk by casting the ActivityExecution interface to the implementation
    class ExecutionImpl. 
    </p><p>When <code class="literal">ActivityBehaviour</code> implementations used for activity behviour 
    don't call any of the following execution propagation methods, then, after 
    the activity is executed, the execution will apply the implicit proceed behaviour. 
    </p><p>The implicit proceed behaviour is defined as follows:</p><div class="itemizedlist"><ul><li>If the current activity has a default outgoing transition, take it.</li><li>If the current activity has a parent activity, move back to the parent activity.</li><li>Otherwise, end this execution.</li></ul></div><p>Process languages can overwrite the implicit proceed behaviour 
    by overriding the <code class="literal">proceed</code> method in 
    <code class="literal">ExecutionImpl</code>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="functionalactivities"/>9.3. Functional activities</h2></div></div></div><p>ActivityBehaviours that also can be used as event listeners are called functional 
    activities. Examples of automatic activities are sending an email, doing a database 
    update, generating a pdf, calculating an average, etc.  All of these are automatic 
    activities that do not change the execution flow.  Here's how such activities can 
    be implemented:  
    </p><pre class="programlisting">public class FunctionalActivity implements ActivityBehaviour, EventListener {
    public void execute(ActivityExecution execution) {
      perform(execution);
    }
    public void notify(EventListenerExecution execution) {
      perform(execution);
    }
    void perform(OpenExecution execution) {
      ...do functional work...
    }
  }</pre><p>The <code class="literal">perform</code> method takes an <code class="literal">OpenExecution</code>, 
    which is the supertype of both <code class="literal">ActivityExecution</code> and 
    <code class="literal">EventListenerExecution</code>.  <code class="literal">OpenExecution</code>
    does not allow any of the specific purpose methods, but still 
    the current state and the process definition can be inspected as well 
    as the variables, which contain the context information for the process 
    execution.
    </p><p>None of these methods actually invoke execution propagation methods.
    So after the perform method is completed, the execution will
    <a href="#implicitproceedbehaviour" title="9.2. Implicit proceed behaviour">proceed in the default way</a>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="executionandthreads"/>9.4. Execution and threads</h2></div></div></div><p>This section explains how the Process Virtual Machine boroughs the thread
    from the client to bring an execution from one wait state to another.
    </p><p>When a client invokes a method (like e.g. the signal method) on an execution, 
    by default, the Process Virtual Machine will use that thread to progress the execution
    until it reached a wait state.  Once the next wait state has been reached, the 
    method returns and the client gets the thread back.  This is the default way 
    for the Process Virtual Machine to operate.  Two more levels of asynchonous 
    execution complement this default behaviour: 
    <a href="#">Asynchronous continuations</a>
    and in the future we'll also provide a way to invoke service methods asynchronously.
    </p><p>TODO: update the example that is now commented</p><p>The benefits of using this paradigm is that the same process definition 
    can be executed in <a href="#">client execution mode</a> 
    (in-memory without persistence) as well as in <a href="#">
    persistent execution mode</a>, depending on the application and on the environment.
    </p><p>When executing a process in persistent mode, this is how you typically want 
    to bind that process execution to transactions of the database:
    </p><div class="figure"><a id="transactions.png"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/transactions.png" align="middle" alt="Transactions over time in persistent execution mode."/></div></div><p class="title"><b>Figure 9.1. Transactions over time in persistent execution mode.</b></p></div><br class="figure-break"/><p>In most situations, the computational work that needs to be done as part of 
    the process after an external trigger (the red pieces) is pretty minimal.  Typically 
    transactions combining the process execution and processing the request from the 
    UI takes typically less then a second.  Whereas the wait state in business processes 
    typically can span for hours, days or even years.  The clue is to clearly distinct 
    when a wait state starts so that only the computational work done before the start 
    of that wait state should be included in the transaction.  
    </p><p>Think of 
    it this way: "When an approval arrives, what are all the automated processing that 
    needs to be done before the process system needs to wait for another external 
    trigger?"  Unless pdf's need to be generated or mass emails need to be send,
    the amount of time that this takes is usually neglectable.  That is why in the 
    default persistent execution mode, the process work is executed in the thread 
    of the client.
    </p><p>This reasoning even holds in case of concurrent paths of execution.  
    When a single path of execution splits into concurrent paths of execution,
    the process overhead of calculating that is neglectable.  So that is why it 
    makes sense for a fork or split activity implementation that targets persistent 
    execution mode to spawn the concurrent paths sequentially in the same thread.
    Basically it's all just computational work as part of the same transaction.
    This can only be done because the fork/split knows that each concurrent path 
    of execution will return whenever a wait state is encountered. 
    </p><p>Since this is a difficult concept to grasp, I'll explain it again with other 
    words.  Look at it from the overhead that is produced by the process execution 
    itself in persistent execution mode.  If in a transaction, an execution is given 
    an external trigger and that causes the execution to split into multiple concurrent 
    paths of execution.  Then the process overhead of calculating this is neglectable. 
    Also the overhead of the generated SQL is neglectable.  And since all the work done 
    in the concurrent branches must be done inside that single transaction, there is 
    typically no point in having fork/split implementations spawn the concurrent 
    paths of execution in multiple threads. 
    </p><p>To make executable processes, developers need to know exactly what the automatic activities
    are, what the wait states are and which threads will be allocated to the process execution.  
    For business analysts that draw the analysis process, things are a bit simpler.   For the  
    activities they draw, they usually know whether it's a human or a system that is responsible.
    But they typically don't not how this translates to threads and transactions.
    </p><p>So for the developer, the first job is to analyse what needs to be executed 
    within the thread of control of the process and what is outside.  Looking for the external 
    triggers can be a good start to find the wait states in a process, just like verbs and nouns 
    can be the rule of thumb in building UML class diagrams. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4087"/>9.5. Process concurrency</h2></div></div></div><p>To model process concurrency, there is a parent-child tree structure on the 
    execution. The idea is that the main path of execution is the root of that tree.
    The main path of execution is also called the process instance.  It is the execution 
    that is created when starting or creating a new process instance for a given  
    process definition. 
    </p><p>Now, because the main path of execution is the same object as the 
    process instance, this keeps the usage simple in case of simple processes 
    without concurrency. 
    </p><div class="figure"><a id="execution.structure"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/class.diagram.process.execution.png" align="middle" alt="UML class diagram of the basic execution structure"/></div></div><p class="title"><b>Figure 9.2. UML class diagram of the basic execution structure</b></p></div><br class="figure-break"/><p>To establish multiple concurrent paths of execution, activity implementations 
    like a fork or split can create child executions with method 
    <code class="literal">ActivityExecution.createExecution</code>.  Activity implementations 
    like join or merge can stop these concurrent paths of execution by calling 
    method <code class="literal">stop</code> on the concurrent execution.  
    </p><p>Only leaf executions can be active.  Non-leave executions should be 
    inactive.  This tree structure of executions doesn't enforce a particular type of 
    concurrency or join behaviour.  It's up to the forks or and-splits and to the joins 
    or and-merges to use the execution tree structure in any way they want to define 
    the wanted concurrency behaviour.  Here you see an example 
    of concurrent executions. 
    </p><div class="figure"><a id="concurrency"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/execution.concurrency.png" align="middle" alt="Concurrent paths of execution"/></div></div><p class="title"><b>Figure 9.3. Concurrent paths of execution</b></p></div><br class="figure-break"/><p>There is a billing and a shipping path of execution.  In this case, the 
    flat bar activities represent activities that fork and join.  The execution shows a three 
    executions.  The main path of execution is inactive (represented as gray) and the 
    billing and shipping paths of execution are active and point to the activity 
    <code class="literal">bill</code> and <code class="literal">ship</code> respectively.
    </p><p>It's up to the activity behaviour implementations how they want to use this 
    execution structure.  Suppose that multiple tasks have to be completed before the 
    execution is to proceed.  The activity behaviour can spawn a series of child executions 
    for this.  Or alternatively, the task component could support task groups that 
    are associated to one single execution.  In that case, the task component becomes
    responsible for synchronizing the tasks, thereby moving this responsibility 
    outside the scope of the execution tree structure.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4127"/>9.6. Exception handlers</h2></div></div></div><p>In all the code that is associated to a process
    like <code class="literal">Activity</code>s, <code class="literal">EventListeners</code> and 
    <code class="literal">Condition</code>s, it's possible to associate exception handlers.  This 
    can be thought of as including try-catch blocks in 
    the method implementations of those implementations.  But in order to build more reusable building 
    blocks for both the delegation classes and the exception handling logic, exception handlers are 
    added to the core process model. 
    </p><p>An exception handler can be associated to any process element.  When an exception 
    occurs in a delegation class, a matching exception handler will be searched for.  If 
    such an exception handler is found, it will get a chance to handle the exception.
    </p><p>If an exception handler completes without problems, then the exception is considered 
    handled and the execution resumes right after the delegation code that was called.  For example,
    a transition has three actions and the second action throws an exception that is handled 
    by an exception handler, then   
    </p><p>Writing automatic activities that are exception handler aware is easy.  The 
    default is to proceed anyway.  No method needs to be called on the execution.  So 
    if an automatic activity throws an exception that is handled by an exception handler,
    the execution will just proceed after that activity.  It becomes a big more difficult 
    for control flow activities.  They might have to include try-finally blocks to 
    invoke the proper methods on the execution before an exception handler gets a 
    chance to handle the exception.  For example, if an activity is a wait state and 
    an exception occurs, then there is a risk that the thread jumps over the 
    invocation of <code class="literal">execution.waitForSignal()</code>, causing the execution 
    to proceed after the activity. 
    </p><p>TODO: exceptionhandler.isRethrowMasked</p><p>TODO: transactional exception handlers</p><p>TODO: we never catch errors</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4157"/>9.7. Process modifications</h2></div></div></div><p>TODO: process modifications</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4163"/>9.8. Locking and execution state</h2></div></div></div><p>The state of an execution is either active or locked. An active 
    execution is either executing or waiting for an external trigger. If an 
    execution is not in <code class="literal">STATE_ACTIVE</code>, then it is locked. 
    A locked execution is read only and cannot receive any external triggers.
    </p><p>When a new execution is created, it is in STATE_ACTIVE. To change 
    the state to a locked state, use lock(String). Some STATE_* constants 
    are provided that represent the most commonly used locked states. But 
    the state '...' in the picture indicates that any string can be provided 
    as the state in the lock method.
    </p><div class="figure"><a id="execution.states"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/ch04.execution.states.png" align="middle" alt="States of an execution"/></div></div><p class="title"><b>Figure 9.4. States of an execution</b></p></div><br class="figure-break"/><p>If an execution is locked, methods that change the execution will 
    throw a PvmException and the message will reference the actual locking state. 
    Firing events, updating variables, updating priority and adding comments 
    are not considered to change an execution. Also creation and removal of child 
    executions are unchecked, which means that those methods can be invoked by 
    external API clients and activity behaviour methods, even while the execution 
    is in a locked state.
    </p><p>Make sure that comparisons between getState() and the STATE_* constants 
    are done with .equals and not with '==' because if executions are loaded 
    from persistent storage, a new string is created instead of the constants.
    </p><p>An execution implementation will be locked:
    </p><div class="itemizedlist"><ul><li>When it is ended</li><li>When it is suspended</li><li>During asynchronous continuations</li></ul></div><p>Furthermore, locking can be used by Activity implementations to make 
    executions read only during wait states hen responsibility for the execution is 
    transferred to an external entity such as:
    </p><div class="itemizedlist"><ul><li>A human task</li><li>A service invocation</li><li>A wait state that ends when a scanner detects that a file appears</li></ul></div><p>In these situations the strategy is that the external entity should get 
    full control over the execution because it wants to control what is allowed 
    and what not.  To get that control, they lock the execution so that all interactions 
    have to go through the external entity. 
    </p><p>One of the main reasons to create external entities is that they can live
    on after the execution has already proceeded.  For example, in case 
    of a service invocation, a timer could cause the execution to take the timeout transition.
    When the response arrives after the timeout, the service invocation entity should 
    make sure it doesn't signal the execution.  So the service invocation can be 
    seen as a activity instance (aka activity instance) and is unique for every execution 
    of the activity.
    </p><p>External entities themselves are responsible for managing the execution 
    lock.  If the timers and client applications are consequent in addressing the 
    external entities instead of the execution directly, then locking is in theory 
    unnecessary.  It's up to the activity behaviour implementations whether they want 
    to take the overhead of locking and unlocking.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuration"/>Chapter 10. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4210">10.1. Configuration basics</a></span></dt><dt><span class="section"><a href="#customizingthebusinesscalendar">10.2. Customizing the business calendar</a></span></dt><dt><span class="section"><a href="#customizingtheidentitycomponent">10.3. Customizing the identity component</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4210"/>10.1. Configuration basics</h2></div></div></div><p>The userguide explains how to install jBPM into the most 
    common runtime environments.  That is the most simple and convenient 
    way to get started with jBPM. Please use those instructions.
    These docs provide some background information for developers 
    that want to understand more about the way how configurations are 
    handled.  Use at your own risk :-)
    </p><p>The jbpm.jar contains a number of default configuration 
    files that can be imported by the user configuration file.  
    </p><p>This way, it's easy to include 
    or exclude features for users.  And also the configuration details are kept in 
    the implementation so users that only import those configuration files 
    will not be affected when we release changes in those configuration files. 
    </p><p>Configuration files that can be imported by the user's <code class="literal">jbpm.cfg.xml</code>:</p><div class="itemizedlist"><ul><li>jbpm.businesscalendar.cfg.xml</li><li>jbpm.default.cfg.xml</li><li>jbpm.identity.cfg.xml</li><li>jbpm.jbossremote.cfg.xml</li><li>jbpm.jobexecutor.cfg.xml</li><li>jbpm.tx.hibernate.cfg.xml</li><li>jbpm.tx.jta.cfg.xml</li></ul></div><p><code class="literal">jbpm.default.cfg.xml</code>: Contains the default configurations
    like the services, the hibernate configuration (configured from resource jbpm.hibernate.cfg.xml), 
    hibernate session factory, business calendar and so on.
    </p><p>A typical configuration for standard java would look like this:
    </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  
  &lt;jbpm-configuration&gt;
  
    &lt;import resource="jbpm.default.cfg.xml" /&gt;
    &lt;import resource="jbpm.businesscalendar.cfg.xml" /&gt;
    &lt;import resource="jbpm.tx.hibernate.cfg.xml" /&gt;
    &lt;import resource="jbpm.jpdl.cfg.xml" /&gt;
    &lt;import resource="jbpm.identity.cfg.xml" /&gt;
    &lt;import resource="jbpm.jobexecutor.cfg.xml" /&gt;
  
  &lt;/jbpm-configuration&gt;</pre><p>When you want to change the configuration, first consider 
    to change an import with one of the other provided importable 
    configuration files. 
    </p><p>For example, in a JTA environment, replace the import of 
     <code class="literal">jbpm.tx.hibernate.cfg.xml</code> 
    with <code class="literal">jbpm.tx.jta.cfg.xml</code> 
    </p><p>The second way to define a more customized configuration is to 
    specify configuration items directly into the <code class="literal">jbpm.cfg.xml</code>.
    For an example, see <a href="#customizingtheidentitycomponent" title="10.3. Customizing the identity component">Section 10.3, “Customizing the identity component”</a> below.
    The more you customize, the more likely you are doing things we didn't 
    anticipate.
    </p><p>The jbpm.jar contains also following hibernate mapping configuration files:</p><pre class="programlisting">
jbpm.execution.hbm.xml
jbpm.history.hbm.xml
jbpm.identity.hbm.xml
jbpm.repository.hbm.xml
jbpm.task.hbm.xml</pre><p>These all map the java domain model objects to a relational database.
    </p><p>Other various configuration files that are included in jbpm.jar:</p><pre class="programlisting">
jbpm.task.lifecycle.xml
jbpm.variable.types.xml
jbpm.wire.bindings.xml
jbpm.jpdl.activities.xml
jbpm.jpdl.eventlisteners.xml</pre><p>Normally it is not necessary to dive into the parsing itself.  It's most 
    a matter of figuring out how to specify the configuration that you want :-)
    But just in case: To get started on the parsing for the configuration files, see
    </p><div class="itemizedlist"><ul><li>class org.jbpm.pvm.internal.env.JbpmConfigurationParser</li><li>resource modules/pvm/src/main/resources/jbpm.wire.bindings.xml</li><li>package modules/pvm/src/main/java/org/jbpm/pvm/internal/wire/binding</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="customizingthebusinesscalendar"/>10.2. Customizing the business calendar</h2></div></div></div><p>To provide a custom implementation for the business calendar, 
    specify a custom business calendar implementation like this in 
    the jbpm.cfg.xml
    </p><pre class="programlisting">&lt;jbpm-configuration&gt;

  &lt;import resource="jbpm.default.cfg.xml" /&gt;
  ...

  &lt;process-engine-context&gt;
    &lt;object class="org.jbpm.test.custombusinesscalendarimpl.CustomBusinessCalendar" /&gt;
  &lt;/process-engine-context&gt;

&lt;/jbpm-configuration&gt;</pre><p>Here's an example implementation</p><pre class="programlisting">public class CustomBusinessCalendar implements BusinessCalendar {
  
  public Date add(Date date, String duration) {
    if ("my next birthday".equals(duration)) {
      GregorianCalendar gregorianCalendar = new GregorianCalendar();
      gregorianCalendar.set(Calendar.MONTH, Calendar.JULY);
      gregorianCalendar.set(Calendar.DAY_OF_MONTH, 21);
      return gregorianCalendar.getTime();
    }
    return null;
  }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="customizingtheidentitycomponent"/>10.3. Customizing the identity component</h2></div></div></div><p>There are 2 identity components that we support out of the box:
    </p><div class="itemizedlist"><ul><li>jBPM's built-in identity component: ships with the jBPM project distro</li><li>JBoss IDM: ships in the JBoss product platforms</li></ul></div><p>The <code class="literal">jboss/build.xml</code> installation scripts can be used 
    to install jBPM in JBoss using the JBoss IDM component.   There is some 
    property in that build file to overwrite the default built-in identity component
    with the value for the JBoss IDM component.
    </p><p>If you want to plug in your own identity component, remove the 
    following line in the <code class="literal">jbpm.cfg.xml</code>:
    </p><pre class="programlisting">&lt;import resource="jbpm.identity.cfg.xml" /&gt;</pre><p>And in the same file, add following section</p><pre class="programlisting">&lt;transaction-context&gt;
  &lt;object class="your.package.YourIdentitySessionImpl" /&gt;
&lt;/transaction-context&gt;</pre><p>YourIdentitySessionImpl should implement <code class="literal">org.jbpm.pvm.internal.identity.spi.IdentitySession</code>
    Making this identity pluggable is not our first target, but it was taken into the design. Let us know how it goes.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="persistence"/>Chapter 11. Persistence</h2></div></div></div><p>Currently jBPM's persistence is based on hibernate.  But in the future we might 
  switch to JPA.  That is why we recommend to stick with the API as much as possible as 
  the API will hide you from those changes.
  </p><p>Here's the jBPM database schema in an ER diagram.  Thanks to 
  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://dev.mysql.com/workbench/">MySQL Workbench&gt;</a>.
  </p><div class="figure"><a id="erd.repo.and.runtime"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/erd.repo.and.runtime.png" align="middle" alt="The jBPM repository and runtime schema ER diagram"/></div></div><p class="title"><b>Figure 11.1. The jBPM repository and runtime schema ER diagram</b></p></div><br class="figure-break"/><div class="figure"><a id="erd.history"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/erd.history.png" align="middle" alt="The jBPM history schema ER diagram"/></div></div><p class="title"><b>Figure 11.2. The jBPM history schema ER diagram</b></p></div><br class="figure-break"/><div class="figure"><a id="erd.identity"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/erd.identity.png" align="middle" alt="The jBPM identity schema ER diagram"/></div></div><p class="title"><b>Figure 11.3. The jBPM identity schema ER diagram</b></p></div><br class="figure-break"/></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="jobexecutor"/>Chapter 12. JobExecutor</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#overview">12.1. Overview</a></span></dt><dt><span class="section"><a href="#configuration">12.2. Configuration</a></span></dt></dl></div><p>
	For jPDL features like asynchronous continuations and timers, jBPM
	relies on transactional asynchronous messaging and
	timers. Those are not available on the standard Java platform.
	Therefore, jBPM includes the JobExecutor component, which executes
	asynchronous messages and timers in any (potentially clustered)
	environment. 
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="overview"/>12.1. Overview</h2></div></div></div><p>
		By default, when calling a jBPM service operation (eg. TaskService,
		ExecutionService, etc.), the jBPM logic is executed on the same thread
		as where the call came from. In most cases, this is sufficient since
		most steps in a process don't take much time. This means that
		signalling a process instance from one wait state to another, passing
		by several other steps in the business process, can be done in one
		transaction.
    </p><p>
		However, in some occasions business processes can be made more efficient by
		introducing asynchronous continuations. By marking an activity as
		asynchronous, the jBPM engine will take care that the logic
		encapsulated in the activity isn't executed on the thread of the
		caller, but on a separate dedicated thread. The same mechanism is used
		for timers and asynchronous mailing (which means mails will be sent
		later, in a separate thread). The following picture shows which components
		come into play when using this mechanism.
    </p><div class="figure"><a id="jobexecutor.overview.image"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/jobexecutor.overview.png" align="middle" alt="JobExecutor components overview"/></div></div><p class="title"><b>Figure 12.1. JobExecutor components overview</b></p></div><br class="figure-break"/><p>
		When using timers or asynchronous continuations in a business process, the
		jBPM engine will store a 'job' into the database (a job contains mainly a 
		duedate and continuation logic). Do note that this mechanism is
		pluggable, which means that in the future other destinations could be
		used (JMS, JCR, etc).
    </p><p>
		Now the JobExecutor comes in to play, which is in fact a manager
		for several subcomponents:
		
		</p><div class="itemizedlist"><ul><li>
				A <span class="bold"><strong>shared BlockingQueue</strong></span>, 
				which is used to temporary store job identifiers of jobs which 
				are executable (e.g. due date is passed).
			</li><li>
				Every JobExecutor has one <span class="bold"><strong>DispatcherThread.</strong></span> 
				This thread	will query the database for 'acquirable jobs' (e.g. timers 
				which due date is passed), using a dedicated command through the CommandService.
				Since the dispatcher uses the CommandService, the command is
				automatically made transactional and wrapped by the configured
				interceptors. As long as jobs are available the dispatcher will put
				job identifiers on the shared queue, until the queue is either full
				(the thread will automatically be blocked by the JVM until a slot is
				free) or until no new jobs can be found in the database. If the latter
				case, the dispatcher will wait for a configured time (ie the 'idle
				time').
  		</li><li>
				The JobExecutor also maintains a pool of job executor threads. The number of
				executor threads can be configured and influences the size of the shared
        queue used to transfer and hold submitted jobs. Each executor thread will take a
				job from the queue. The shared queue blocks the executor threads until a job
        is queued. The new job will be acquired by exactly one waiting executor thread.
				After taking a job from the queue, the job is transactionally
				executed using a dedicated command through the CommandService. Therefore,
        the job will be executed completely on the executor thread
        instead of the caller thread. In consequence, the order in which the jobs
        are executed is unknown since	there are multiple competing executor threads.
        However, it is certain that only one job will be done per transaction,
        except for <span class="emphasis"><em>exclusive</em></span> jobs. In this case,
        all exclusive jobs are sequentially	executed.
			</li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuration"/>12.2. Configuration</h2></div></div></div><p>
      Enabling the jobExecutor is very easy by adding the following line to the 
      jbpm.cfg.xml file (using default settings):
    </p><pre class="programlisting">
	  &lt;import resource="jbpm.jobexecutor.cfg.xml" /&gt;
	</pre><p>
	  Additional attributes can be set to fine-tune the JobExecutor:
	  </p><div class="itemizedlist"><ul><li><span class="bold"><strong>threads:</strong></span> defines the number of 
	      JobexecutorThreads (default 3 threads)
	    </li><li><span class="bold"><strong>idle:</strong></span> number of milliseconds the dispatcher
	      component waits after no new jobs were found in the database (default 5 seconds) 
	    </li><li><span class="bold"><strong>idle-max:</strong></span> each time an exception occurs, 
	      the idle period will be doubled until the 'idle-max' is reached 
	      (back-off mechanism used to avoid a constant load on a failing database)
	    </li><li><span class="bold"><strong>lock-millis:</strong></span> Number of milliseconds 
	      that a job will be locked after being acquired by the dispatcher. 
	      This prevents starvation in case one of more JobExecutorThreads would die
	      (eg when used in a cluster).
	    </li></ul></div><p>
	  </p><pre class="programlisting">
		
		&lt;process-engine-context&gt;
		  
		    &lt;job-executor threads="4" idle="15000" idle-max="60000" lock-millis="3600000" /&gt;
		
		&lt;/process-engine-context&gt;
	  </pre><p>
	</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mailsupport"/>Chapter 13. Advanced Mail Support</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#mailproducers">13.1. Producers</a></span></dt><dd><dl><dt><span class="section"><a href="#defaultmailproducer">13.1.1. Default Producer</a></span></dt></dl></dd><dt><span class="section"><a href="#mailtemplates">13.2. Templates</a></span></dt><dt><span class="section"><a href="#mailservers">13.3. Servers</a></span></dt><dd><dl><dt><span class="section"><a href="#multiplemailservers">13.3.1. Multiple Servers</a></span></dt></dl></dd><dt><span class="section"><a href="#custommailproducers">13.4. Custom Mail Producers</a></span></dt><dd><dl><dt><span class="section"><a href="#extenddefaultmailproducer">13.4.1. Extending the default mail producer</a></span></dt></dl></dd></dl></div><p>jBPM 4 takes advantage of the JavaMail API to make high-level email
    services available to business process authors.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mailproducers"/>13.1. Producers</h2></div></div></div><p>Mail producers are responsible for creating email messages within jBPM. Producers 
      implement the <code class="literal">org.jbpm.pvm.internal.email.spi.MailProducer</code> interface.
      A default producer is available out of the box to address typical email needs.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="defaultmailproducer"/>13.1.1. Default Producer</h3></div></div></div><p>The default mail producer is capable of creating email messages with text,
        HTML and attachments from a template. Templates can be provided inline or
        in the process-engine-context section of the jBPM configuration. Templates
        may contain expressions which are evaluated through the script manager.
      </p><p>The following listing presents a mail activity with an inline template.</p><pre class="programlisting">&lt;mail name="rectify" language="juel"&gt;                             (1)
  &lt;from addresses='winston@minitrue' /&gt;                           (2)
  &lt;to addresses='julia@minitrue, obrien@miniluv'/&gt;                (3)
  &lt;cc users='bigbrother'/&gt;
  &lt;bcc groups='thinkpol, innerparty'/&gt;
  &lt;subject&gt;Part ${part} Chapter ${chapter}&lt;/subject&gt;              (4)
  &lt;text&gt;times ${date} reporting bb dayorder doubleplusungood      (5)
    refs ${unpersons} rewrite fullwise upsub antefiling&lt;/text&gt;
  &lt;html&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;times&lt;/td&gt;&lt;td&gt;${date}&lt;/td&gt;                 (6)
    &lt;td&gt;reporting bb dayorder doubleplusungood 
    refs ${unpersons} rewrite fullwise upsub antefiling&lt;/td&gt;
    &lt;/tr&gt;&lt;/table&gt;&lt;/html&gt;
  &lt;attachments&gt;                                                   (7)
    &lt;attachment url='http://www.george-orwell.org/1984/3.html'/&gt;
    &lt;attachment resource='org/example/pic.jpg'/&gt;
    &lt;attachment file='${user.home}/.face'/&gt;
  &lt;/attachments&gt;
&lt;/mail&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Expressions within the template are written in the scripting language
        indicated here. If not specified, the default expression language will be assumed.
        </p></li><li><p>List of message senders. Senders are either identified directly by
        their email addresses or appointed by means of the identity model.</p></li><li><p>Lists of message recipients, categorized as follows: <span class="emphasis"><em>To</em></span>
        (primary), <span class="emphasis"><em>CC</em></span> (carbon copy) and <span class="emphasis"><em>BCC</em></span> (blind 
        carbon copy). Like senders, recipients are directly identified by their email addresses
        or appointed by means of the identity model.</p></li><li><p>Character data contained in element <code class="literal">subject</code> 
        are used as the message subject.</p></li><li><p>Character data contained in element <code class="literal">text</code> 
        are used as the plain text content of the message.</p></li><li><p>Nodes contained in element <code class="literal">html</code>
        are used as the HTML content of the message.</p></li><li><p>Attachments can be specified as absolute URLs,
        classpath resources, local files or expressions.</p></li></ol></div><p>Note that every section of the template is amenable to expression evaluation.</p></div><p>For complex emails or custom generation of attachments, see: <a href="#custommailproducers" title="13.4. Custom Mail Producers">custom mail producers</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mailtemplates"/>13.2. Templates</h2></div></div></div><p>Mail templates are available to externalize commonly used messages from process definitions.
      Templates are placed in the process-engine-context section of your configuration file. All elements
      available to inline templates, as described in the <a href="#defaultmailproducer" title="13.1.1. Default Producer">previous
      section</a> are available to external templates. Consider the fragment below.</p><pre class="programlisting">&lt;jbpm-configuration&gt;
&lt;process-engine-context&gt;
  &lt;mail-template name="rectify-template"&gt;
    &lt;!-- same elements as inline template --&gt;
  &lt;/mail-template&gt;
&lt;/process-engine-context&gt;
&lt;/jbpm-configuration&gt;</pre><p>Each template must have an unique name. Mail activities may reference the template
      through the <code class="literal">template</code> attribute, as follows.</p><pre class="programlisting">&lt;mail name="rectify" template="rectify-template /&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mailservers"/>13.3. Servers</h2></div></div></div><p>Mail servers are declared in the configuration file. The <code class="literal">mail-server</code>
      element describes an SMTP mail server capable of sending email messages.
      Because jBPM uses JavaMail to send mail, all properties supported by JavaMail are also
      exposed to jBPM.  Within the <code class="literal">session-properties</code> child element, 
      the SMTP properties must be provided as shown in the example below.</p><p>See the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/products/javamail/javadocs/com/sun/mail/smtp/package-summary.html">
      JavaMail documentation</a> for details on the supported properties.</p><pre class="programlisting">&lt;jbpm-configuration&gt;
&lt;transaction-context&gt;
  &lt;mail-session&gt;
    &lt;mail-server&gt;
      &lt;session-properties&gt;
        &lt;property name="mail.smtp.host" value="localhost" /&gt;
        &lt;property name="mail.smtp.port" value="2525" /&gt;
        &lt;property name="mail.from" value="noreply@jbpm.org" /&gt;
      &lt;/session-properties&gt;
    &lt;/mail-server&gt;
  &lt;/mail-session&gt;
&lt;/transaction-context&gt;
&lt;/jbpm-configuration&gt;</pre><p>If the "From" attribute is not present in an outgoing message, the value of the 
      <code class="literal">mail.from</code> property will be used instead.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="multiplemailservers"/>13.3.1. Multiple Servers</h3></div></div></div><p>Multiple SMTP server support has been added to jBPM 4 to accommodate a wider
        variety of organizational server structures. For example, this is useful for companies
        that have both internal and external SMTP servers.</p><p>To setup multiple SMTP mail servers, declare multiple mail servers within the 
        configuration file, as described below. The tag <code class="literal">address-filter</code> exists
        to define which domains are serviced by each mail server. The address filter consists
        of regular expressions that determine whether an address will be processed by a given
        server.</p><p>See the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">Pattern
        API</a> for more information about the allowable regular expressions.</p><pre class="programlisting">&lt;jbpm-configuration&gt;
&lt;transaction-context&gt;
  &lt;mail-session&gt;
    &lt;mail-server&gt;
      &lt;address-filter&gt;
        &lt;include&gt;.+@example.com&lt;/include&gt;
      &lt;/address-filter&gt;
      &lt;session-properties&gt;
        &lt;property name="mail.smtp.host" value="internal.smtp.example.com" /&gt;
        &lt;property name="mail.from" value="noreply@example.com" /&gt;
      &lt;/session-properties&gt;
    &lt;/mail-server&gt;
    &lt;mail-server&gt;
      &lt;address-filter&gt;
        &lt;exclude&gt;.+@example.com&lt;/exclude&gt;
      &lt;/address-filter&gt;
      &lt;session-properties&gt;
        &lt;property name="mail.smtp.host" value="external.smtp.example.com" /&gt;
        &lt;property name="mail.from" value="noreply@example.com" /&gt;
      &lt;/session-properties&gt;
    &lt;/mail-server&gt;
  &lt;/mail-session&gt;
&lt;/transaction-context&gt;
&lt;/jbpm-configuration&gt;</pre><p>Address filters follow the logic below to accept an address.</p><div class="itemizedlist"><ul><li><p>Address is accepted if it is <span class="emphasis"><em>included</em></span> and
        <span class="emphasis"><em>not excluded</em></span>.</p></li><li><p>Absence of includes implies the address is 
        <span class="emphasis"><em>included</em></span>.</p></li><li><p>Absence of excludes implies the address is 
        <span class="emphasis"><em>not excluded</em></span>.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="custommailproducers"/>13.4. Custom Mail Producers</h2></div></div></div><p>jBPM 4 allows the creation of custom mail producers to address the specific
      requirements of an organization. To do so, create a class that implements the 
      <code class="literal">org.jbpm.pvm.internal.email.spi.MailProducer</code> interface. Method
      <code class="literal">produce</code> takes an Execution and returns a collection of 
      <code class="literal">Message</code>s to be sent through the <code class="literal">MailSession</code>.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="extenddefaultmailproducer"/>13.4.1. Extending the default mail producer</h3></div></div></div><p>The underpinning of customized mail production is the ability to instantiate
        a class that implements the MailProducer interface. In the simplest scenario,
        the class will extend the default mail producer and make a small addition such
        as adding more recipients. The following process snippet shows a mail
        activity with a custom mail producer.</p><pre class="programlisting">&lt;mail name='send mail' class='org.example.AuditMailProducer'&gt;
  &lt;property name='template'&gt;
    &lt;object method='getTemplate'&gt;
      &lt;factory&gt;&lt;ref type='org.jbpm.pvm.internal.email.impl.MailTemplateRegistry'/&gt;&lt;/factory&gt;
      &lt;arg&gt;&lt;string value='rectify-template'/&gt;&lt;/arg&gt;
    &lt;/object&gt;
  &lt;/property&gt;
  &lt;property name='auditGroup'&gt;&lt;string value='thinkpol'/&gt;&lt;/property&gt;
  &lt;transition to='end' /&gt;
&lt;/mail&gt;</pre><p>The Java code for the <code class="classname">AuditMailProducer</code> comes next.</p><pre class="programlisting">public class AuditMailProducer extends MailProducerImpl {
  private String auditGroup;

  public String getAuditGroup() {
    return auditGroup;
  }
  public void setAuditGroup(String auditGroup) {
    this.auditGroup = auditGroup;
  }

  @Override
  protected void fillRecipients(Execution execution, Message email) throws MessagingException {
    // add recipients from template
    super.fillRecipients(execution, email);

    // load audit group from database
    EnvironmentImpl environment = EnvironmentImpl.getCurrent();
    IdentitySession identitySession = environment.get(IdentitySession.class);
    Group group = identitySession.findGroupById(auditGroup);

    // send a blind carbon copy of every message to the audit group
    AddressResolver addressResolver = environment.get(AddressResolver.class);
    email.addRecipients(RecipientType.BCC, addressResolver.resolveAddresses(group));
  }
}</pre><p><code class="classname">MailProducerImpl</code> exposes a <code class="literal">template</code>
        property. To access a mail template, the mail producer descriptor references
        the <code class="classname">MailTemplateRegistry</code> object and invokes its
        <code class="methodname">getTemplate</code> method. This method takes one string
        parameter, the name of the desired template.</p><p><code class="classname">AuditMailProducer</code> adds an extra property,
        the identifier of the group that will receive blind carbon copies of the
        outgoing emails. The audit mail producer overrides the default 
        <code class="methodname">fillRecipients</code> implementation to add the
        extra BCC recipients.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="softwarelogging"/>Chapter 14. Software logging</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4626">14.1. Configuration</a></span></dt><dt><span class="section"><a href="#d0e4645">14.2. Categories</a></span></dt><dt><span class="section"><a href="#d0e4658">14.3. JDK logging</a></span></dt><dt><span class="section"><a href="#d0e4688">14.4. Debugging persistence</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4626"/>14.1. Configuration</h2></div></div></div><p>PVM can use JDK logging (java.util.logging) or log4j. When the first message is 
    logged, PVM logging will make the selection with following procedure:
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>If a <code class="literal">logging.properties</code> resource is found 
      on the classpath (using the context classloader), then JDK logging will 
      be used and that file will be used to initialize the JDK logging.
      </li><li>If log4j is found on the classpath, then log4j will be used.
      The check for log4j will be done by checking availability of class 
      <code class="literal">org.apache.log4j.LogManager</code> with the context classloader.
      </li><li>If none of the above, JDK logging will be used.</li></ol></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4645"/>14.2. Categories</h2></div></div></div><p>The PVM classes use their class name as the category for the logger.
    </p><p>To have a basic understanding of what the PVM classes are doing, 
    turning on the <code class="literal">debug</code> level is great.  Level 
    <code class="literal">trace</code> might be spitting out too much for that 
    purpose. 
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4658"/>14.3. JDK logging</h2></div></div></div><p>In JDK logging, <code class="literal">debug</code> maps to <code class="literal">fine</code> 
    and <code class="literal">trace</code> maps to <code class="literal">finest</code>. 
    Level <code class="literal">finer</code> is not used.
    </p><p><code class="literal">org.jbpm.pvm.internal.log.LogFormatter</code> is part of 
    the pvm library and it can create a nice one-line output for log messages.
    It also has a neat feature that creates a unique indentation per thread.
    To configure it, this is a typical <code class="literal">logging.properties</code>
    </p><pre class="programlisting">handlers = java.util.logging.ConsoleHandler
java.util.logging.ConsoleHandler.level = FINEST
java.util.logging.ConsoleHandler.formatter = org.jbpm.pvm.internal.log.LogFormatter

# For example, set the com.xyz.foo logger to only log SEVERE messages:
# com.xyz.foo.level = SEVERE

.level = SEVERE
org.jbpm.level=FINE
org.jbpm.tx.level=FINE
org.jbpm.pvm.internal.wire.level=FINE</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4688"/>14.4. Debugging persistence</h2></div></div></div><p>When testing the persistence, following logging configurations can be 
    valuable.  Category <code class="literal">org.hibernate.SQL</code> shows the SQL statement that is executed 
    and category <code class="literal">org.hibernate.type</code> shows the values of the parameters that are 
    set in the queries. 
    </p><pre class="programlisting">org.hibernate.SQL.level=FINEST
org.hibernate.type.level=FINEST</pre><p>And in case you get a failed batch as a cause in a hibernate exception,
    you might want to set the batch size to 0 like this in the hibernate properties:
    </p><pre class="programlisting">hibernate.jdbc.batch_size = 0</pre><p>Also in the hibernate properties, the following properties allow for 
    detailed logs of the SQL that hibernate spits out:</p><pre class="programlisting">hibernate.show_sql = true
hibernate.format_sql = true
hibernate.use_sql_comments = true</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="history"/>Chapter 15. History</h2></div></div></div><p>History information is the information that will be maintained in the database 
    for querying purposes.  This information is kept in the database after the 
    process or task has ended.  But it is always up to date with the runtime 
    information.  History information is updated inside of the runtime 
    transaction.
    </p><p>We maintain history information on 4 entities: process instance, activity instance
    task and variable.  Each entity has a list of details associated to it.
    Preferably use the history queries to access this information through the API.
    </p><p>HistoryEvents are fired during process execution and dispatched to the configured 
    HistorySession.  (see HistoryEvent.fire)  All the HistoryEvents are delegated to a HistorySession.  The default HistorySessionImpl 
    will invoke the process() method on the history events themselves.
    </p><p>The HistoryEvents are temporary events.  In the process method, they build up the information 
    in the history model.  There is a HistoryProcessInstance and there is a whole class hierarchy starting with HistoryActivityInstance.   
    </p><p>In the HistoryEvent.process methods, the history events create model entities or merge 
    information into the history entities.  For instance, a ProcessInstanceCreate history event will 
    create a HistoryProcessInstance entity/record.  And the ProcessInstanceEnd will set the endTime 
    property in the existing HistoryProcessInstance entity/record.  
    </p><p>Similar pattern for the activities.  But for automatic activities, there is an optimisation 
    so that only 1 event is created and all the information is stored in one single insert (as all 
    this happens inside 1 transaction).
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="jbossintegration"/>Chapter 16. JBoss Integration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4736">16.1. Packaging process archives</a></span></dt><dt><span class="section"><a href="#d0e4743">16.2. Deploying processes archives to a JBoss instance</a></span></dt><dt><span class="section"><a href="#d0e4752">16.3. Process deployments and versioning</a></span></dt><dt><span class="section"><a href="#d0e4760">16.4. ProcessEngine and J2EE/JEE programming models</a></span></dt></dl></div><p>
    jBPM provides integration with JBoss 4.2.x and JBoss 5.0.0.GA.
    As part of the <a href="#">installation</a>, the ProcessEngine and a deployer for jBPM archives
    will be installed as a JBoss service.
  </p><p>
    After a successful installation you should see that the ProcessEngine
    has been started and bound to JNDI:
  </p><pre class="programlisting">
    [...]
    14:12:09,301 INFO  [JBPMService] jBPM 4 - Integration JBoss 4
    14:12:09,301 INFO  [JBPMService] 4.0.0.Beta1
    14:12:09,301 INFO  [JBPMService] ProcessEngine bound to: java:/ProcessEngine
  </pre><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4736"/>16.1. Packaging process archives</h2></div></div></div><p>
      When jBPM is deployed on a JBoss instance, process deployments are treated like
      any other deployment artifact (i.e. *.war, *.ear) and processed by the JBPMDeployer.
      In order to deploy a process archive simply create a *.jpdl archive (zip file) that contains
      the process definition (*.jpdl.xml) and all required resources to execute the process (i.e. classes, property files):
    </p><pre class="programlisting">
      Bonanova:Desktop hbraun$ jar -tf OrderProcess.jpdl

      META-INF/MANIFEST.MF
      OrderProcess.jpdl.xml
      org/mycompany/order/*.class
    </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4743"/>16.2. Deploying processes archives to a JBoss instance</h2></div></div></div><p>
      In order to deploy a process archive simply copy it to $JBOSS_HOME/server/&lt;config&gt;/deploy:
    </p><pre class="programlisting">
      (1) cp OrderProcess.jpdl $JBOSS_HOME/server/default/deploy

      (2) less $JBOSS_HOME/server/default/log
      [...]
      2009-04-08 14:12:21,947 INFO  [org.jbpm.integration.jboss4.JBPMDeployer]
      Deploy file:/Users/hbraun/dev/prj/jboss/tags/JBoss_4_2_2_GA
      /build/output/jboss-4.2.2.GA/server/default/deploy/OrderProcess.jpdl
    </pre><p>
      In order to remove a process simply remove the process archive from the deploy directory.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4752"/>16.3. Process deployments and versioning</h2></div></div></div><p>
      TBD: A prelimenary explanation cn be found <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://relative-order.blogspot.com/2009/03/rfc-process-deployment-use-cases.html">here</a>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4760"/>16.4. ProcessEngine and J2EE/JEE programming models</h2></div></div></div><p>
      As described above the ProcessEngine will be installed as JBoss service and bound to JNDI.
      This means that any EE component (i.e. servlet, ejb) can access it doing a JNDI lookup:
    </p><pre class="programlisting">
    private ProcessEngine processEngine;
    [...]

    try
    {
      InitialContext ctx = new InitialContext();
      this.processEngine = (ProcessEngine)ctx.lookup("java:/ProcessEngine");
    }
    catch (Exception e)
    {
      throw new RuntimeException("Failed to lookup process engine");
    }
    </pre><p>
      Once you obtained an instance of the ProcessEngine you can invoke on it
      as described in <a href="#">chapter services</a>
    </p><pre class="programlisting">
    UserTransaction tx = (UserTransaction)ctx.lookup("UserTransaction");        (1)
    Environment env = ((EnvironmentFactory)processEngine).openEnvironment();

    try
    {

      ExecutionService execService = (ExecutionService)
              this.processEngine.get(ExecutionService.class);

      // begin transaction
      tx.begin();

      // invoke on process engine
      executionService.signalExecutionById("ICL.82436");

      // commit transaction
      tx.commit();
      
    }
    catch (Exception e)
    {
      if(tx!=null)
      {
        try
        {
          tx.rollback();
        }
        catch (SystemException e1) {}
      }

      throw new RuntimeException("...", e);

    }
    finally
    {
      env.close();
    }
    </pre><p>
      (1) Wrapping the call in a UserTransaction is not necessary if the invocation comes a
      CMT component, i.e. an EJB.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="springIntegration"/>Chapter 17. Spring Integration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#spring_overview">17.1. Overview</a></span></dt><dt><span class="section"><a href="#spring_configuration">17.2. Configuration</a></span></dt><dt><span class="section"><a href="#spring_usage">17.3. Usage</a></span></dt><dt><span class="section"><a href="#spring_testing">17.4. Testing</a></span></dt></dl></div><p>
    The embeddability of the jBPM engine in different environments has always
    been one of its core strengths, but often extra libraries to do the integration
    were required. Since jBPM4 however, it is now possible to natively
    integrate jBPM with <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.springsource.org/about">Spring</a>.
    This section will explain which steps are required for such an integration.
  </p><p>
    The Spring integration has started out as a community effort by
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.inze.be/andries/">Andries Inzé</a>.
    Do note that Spring integration currently is in 'incubation', before
    it is moved to the user guide.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="spring_overview"/>17.1. Overview</h2></div></div></div><p>
        The default jBPM behaviour is to open a transaction for each operation
        that is called on the service API. In a typical Spring setup, applications are
        accessed from the web tier and enter a transactional boundary by invoking
        operations on service beans. These service beans will then access the jBPM services.
        All these operations run typically in a single transaction (ie one transaction
        per request from the browser), which invalidates the standard jBPM
        transaction handling approach. Instead of starting and committing
        a transaction for every service operation, the existing transaction
        should be used (or a new one started if none exists).
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="spring_configuration"/>17.2. Configuration</h2></div></div></div><p>
    The easiest way to integrate Spring with jBPM is to import the <span class="bold"><strong>jbpm.tx.spring.cfg.xml</strong></span>
    in your jbpm.cfg.xml file:
    </p><pre class="programlisting">
&lt;import resource="jbpm.tx.spring.cfg.xml" /&gt;
    </pre><p>
    This configuration uses the single transaction manager which is defined in the Spring configuration.
    Start from the content of this file if you need to tweak the jBPM-Spring integration
    configuration.
    </p><p>
        If you start from an existing configuration, replace the standard-transaction-interceptor with the
        spring-transaction-interceptor. The hibernate session needs the attribute current=”true”,
        depending if you are using the 'current Session' strategy in Spring.
    Also, the &lt;transaction/&gt; must be removed from the transaction-context if you want the
    transactions to be handled by Spring only.
        This forces jBPM to search for the current session, which will then be provided by Spring.
        </p><pre class="programlisting">
    &lt;process-engine-context&gt;
        &lt;command-service&gt;
          <span class="bold"><strong>&lt;spring-transaction-interceptor /&gt;</strong></span>
          ...
        &lt;/command-service&gt;
        ...
    &lt;/process-engine-context&gt;
    &lt;transaction-context&gt;
        ...
        <span class="bold"><strong>&lt;hibernate-session current="true"/&gt;</strong></span>
    &lt;/transaction-context&gt;
        </pre><p>
    </p><p>
  The spring-transaction-interceptor will look by default for a PlatformTransactionManager
  implementation by doing a search by type on the defined beans. In the case of multiple
  transaction managers, it is possible to specifically define the name of the transaction manager
  that must be used by the interceptor:
  </p><pre class="programlisting">
&lt;spring-transaction-interceptor transaction-manager="<span class="bold"><strong>myTransactionManager</strong></span>" /&gt;
  </pre><p>
    </p><p>
        The Spring integration provides a special context, which is added to
        the set of contexts where the jBPM engine will look for beans.
        Using this SpringContext, it is now possible to retrieve beans from the
        Spring Application Context. The jBPM process engine can be configured in a Spring
        applicationContext.xml as follows:
        </p><pre class="programlisting">
&lt;bean id="springHelper" class="org.jbpm.pvm.internal.processengine.SpringHelper"&gt;
  &lt;property name="jbpmCfg" value="org/jbpm/spring/jbpm.cfg.xml"&gt;&lt;/property&gt;
&lt;/bean&gt;

  &lt;bean id="processEngine" factory-bean="springHelper" factory-method="createProcessEngine" /&gt;
    </pre><p>
    Note that the <span class="bold"><strong>jbpmCfg</strong></span> property for the SpringHelper is optional.
    If a default jbpm.cfg.xml exists on the classpath (ie not in some package), this line can
    be removed.
    </p><p>
        The jBPM services can also be defined in the Spring applicationContext, as following:
        </p><pre class="programlisting">
&lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt;
&lt;bean id="executionService" factory-bean="processEngine" factory-method="getExecutionService" /&gt;
        </pre><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="spring_usage"/>17.3. Usage</h2></div></div></div><p>
        The previous section already showed how the jBPM services can be made
        accessible for other Spring services. The other use case is calling
        Spring beans from within a process. This can be done by using
        an expression which resolves to the name of a Spring bean.

        </p><pre class="programlisting">
&lt;java name="echo" expr="#{echoService}" method="sayHello" &gt;
  &lt;transition name="to accept" to="join1"/&gt;
&lt;/java&gt;
        </pre><p>

        The scripting engine will look into all contexts from the bean named echoService.
        If you configured the ScriptManager as above, Spring will be the last context to search for.
        You can also add a Spring bean to the Spring Application context
        (eg IdentitySessionImpl with id <span class="italic">identitySession</span>)
        and use it in the jBPM config (eg by adding &lt;env class="identitySession" /&gt;)
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="spring_testing"/>17.4. Testing</h2></div></div></div><p>
        Use the <span class="bold"><strong>AbstractTransactionalJbpmTestCase</strong></span>
        to test a process in isolation (ie without impact on the database).
        This class extends from
        the <span class="italic">AbstractTransactionalDataSourceSpringContextTests</span>
        class, which means that testing a process comes down to exactly the same
        approach as testing a DAO.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="signavio"/>Chapter 18. Signavio web modeler</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#signavioIntroduction">18.1. Introduction</a></span></dt><dt><span class="section"><a href="#signavioInstallation">18.2. Installation</a></span></dt><dt><span class="section"><a href="#signavioConfiguration">18.3. Configuration</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="signavioIntroduction"/>18.1. Introduction</h2></div></div></div><p>Since version 4.1, jBPM ships with a completely open-source web-based BPMN 
    modeling tool called 'Signavio'. This Signavio web modeler is the result
    of a close collaboration between the JBoss jBPM team, 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.signavio.com/en.html">the company also named 'Signavio'</a>
    and the Hasso Plattner Instut (HPI) in Germany. Signavio is based on the 
    web-based modeling tool <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://bpt.hpi.uni-potsdam.de/Oryx">
    Oryx</a>, which was developed in open-source by HPI. Both HPI and
    Signavio have comitted themselves to continue investing in Oryx and Signavio.
    More information about the initiative can be found 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://code.google.com/p/signavio-oryx-initiative/">here</a>.</p><p>
    </p><div class="mediaobject" align="center"><img src="images/signavio.screenshot.png" align="middle"/></div><p>
    </p><p>
    Using the Signavio web-based BPMN modeler, it is possible to let business 
    analyst model the business processes through their browser. The file format
    which is used to store the BPMN processes is actually jPDL. This means that
    the resulting processes can directly be imported into the Eclipse GPD and vice-versa. The process
    files will be stored on the hard disk, in 
    <code class="literal">$jbpm_home/signavio-repository</code> if you've used the default
    installation scripts.
    </p><p>
    NOTE: The web-based BPMN modeling tool which ships with jBPM is 100% open-source
    (MIT-licence). The company <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.signavio.com/en.html">Signavio</a>
    also offers commercial versions of the same modeling tool, enhanced with additional 
    features. Do note that new features, beneficial for the jBPM project, always
    will be comitted in the open-source repository of the modeling tool.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="signavioInstallation"/>18.2. Installation</h2></div></div></div><p>
    There are several ways of installing Signavio into your web container:
    </p><div class="itemizedlist"><ul><li>
      Use the demo.setup.jboss/tomcat scripts in <code class="literal">$jbpm_home/install</code></li><li>
      Use the install.signavio.into.jboss/tomcat scripts in <code class="literal">$jbpm_home/install</code></li><li>
      Copy the <code class="literal">$jbpm_home/install/src/signavio/jbpmeditor.war</code> 
      to your web container
      </li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="signavioConfiguration"/>18.3. Configuration</h2></div></div></div><p>
    Most of the Signavio configuration parameters can be changed in the 
    <code class="literal">web.xml</code> file, which you can find in <code class="literal">jbpmeditor.war/WEB-INF/</code>.
    The only parameters which is of real importance is the <code class="literal">fileSystemRootDirectory</code>
    parameter. The value of this parameter must point to an existing folder
    on your hard disk and indicates where the processes must be stored:
    </p><pre class="programlisting">
&lt;/context-param&gt;
  &lt;context-param&gt;
    &lt;description&gt;Filesystem directory that is used to store models&lt;/description&gt;
    &lt;param-name&gt;fileSystemRootDirectory&lt;/param-name&gt;&lt;param-value&gt;/home/jbarrez/dev/temp/jbpm-4.4-SNAPSHOT/signavio-repository&lt;/param-value&gt;
&lt;/context-param&gt;    
   </pre><p>
    </p><p>
    If you use the installation scripts provided in <code class="literal">$jbpm_home/install</code>,
    this parameter is automatically set to <code class="literal">$jbpm_home/signavio-repository</code>
    during installation.
    </p></div></div></div></body></html>